<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="Scay Pig"><meta name="copyright" content="Scay Pig"><meta name="generator" content="Hexo 6.3.0"><meta name="theme" content="hexo-theme-yun"><title>前端面试题 | 咕噜咕噜~~</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.4.1/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/myblog/yun.svg"><link rel="mask-icon" href="/myblog/yun.svg" color="#0078E7"><link rel="preload" href="/myblog/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/myblog/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"scarypig.github.io","root":"/myblog/","title":"春风十里不如你","version":"1.10.9","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"fireworks":{"colors":null},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/myblog/css/hexo-theme-yun.css"><script src="/myblog/js/hexo-theme-yun.js" type="module"></script><meta name="description" content="清除浮动在父元素高度没有定义下，由于浮动在标准流中不占空间，导致后面的标准流元素上移重复，此时要清楚浮动。 1.额外标签法 1clear: left&#x2F;right&#x2F;both  12345&lt;div style&#x3D;&quot;height: 60px;background-color: rgb(231, 23, 23);float: left;&quot;&gt;pig&lt;&#x2F;div&gt;&amp;lt">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试题">
<meta property="og:url" content="https://scarypig.github.io/myblog/2021/09/01/%E9%9D%A2%E8%AF%95/index.html">
<meta property="og:site_name" content="咕噜咕噜~~">
<meta property="og:description" content="清除浮动在父元素高度没有定义下，由于浮动在标准流中不占空间，导致后面的标准流元素上移重复，此时要清楚浮动。 1.额外标签法 1clear: left&#x2F;right&#x2F;both  12345&lt;div style&#x3D;&quot;height: 60px;background-color: rgb(231, 23, 23);float: left;&quot;&gt;pig&lt;&#x2F;div&gt;&amp;lt">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="d:\blog\images\image-20230219223549655.png">
<meta property="og:image" content="d:\blog\images\image-20230219223709206.png">
<meta property="og:image" content="d:\blog\images\image-20230219223716462.png">
<meta property="og:image" content="d:\blog\images\image-20230219224043869.png">
<meta property="og:image" content="d:\blog\images\image-20230219224129060.png">
<meta property="og:image" content="d:\blog\images\image-20230219224145056.png">
<meta property="og:image" content="d:\blog\images\image-20230219224220379.png">
<meta property="og:image" content="d:\blog\images\image-20230219230159352.png">
<meta property="article:published_time" content="2021-09-01T12:38:09.000Z">
<meta property="article:modified_time" content="2023-05-08T09:08:37.720Z">
<meta property="article:author" content="Scay Pig">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:\blog\images\image-20230219223549655.png"><script>(function() {
  if (CONFIG.mode !== 'auto') return
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/myblog/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/myblog/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/myblog/about/" title="Scay Pig"><img width="96" loading="lazy" src="/myblog/yun.png" alt="Scay Pig"></a><div class="site-author-name"><a href="/myblog/about/">Scay Pig</a></div><span class="site-name">咕噜咕噜~~</span><sub class="site-subtitle"></sub><div class="site-description"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/myblog/" title="首页"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/myblog/archives/" title="归档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">47</span></a></div><div class="site-state-item"><a href="/myblog/categories/" title="分类"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">1</span></a></div><div class="site-state-item"><a href="/myblog/tags/" title="标签"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">20</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:settings-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/ScaryPig" title="GitHub" target="_blank" style="color:#6e5494"><span class="icon iconify" data-icon="ri:github-line"></span></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/myblog/links/" title="我的小伙伴们" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8"><span class="toc-number">1.</span> <span class="toc-text">清除浮动</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="toc-number">2.</span> <span class="toc-text">防抖和节流</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#js%E9%97%AD%E5%8C%85"><span class="toc-number">3.</span> <span class="toc-text">js闭包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue%E4%B8%AD%E7%9A%84data%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">vue中的data为什么是一个函数？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#var-let-const-%E5%8C%BA%E5%88%AB"><span class="toc-number">5.</span> <span class="toc-text">var let const 区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">6.</span> <span class="toc-text">解构赋值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MVC%E5%92%8CMVVM%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text">MVC和MVVM的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#v-model-%E5%8E%9F%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text">v-model 原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#v-for%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89key"><span class="toc-number">9.</span> <span class="toc-text">v-for中为什么要有key</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#watch%E5%92%8Ccomputed%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.</span> <span class="toc-text">watch和computed的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92"><span class="toc-number">11.</span> <span class="toc-text">vue组件之间的数据传递</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">12.</span> <span class="toc-text">跨域的解决方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#get%E4%B8%8Epost%E8%AF%B7%E6%B1%82%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">13.</span> <span class="toc-text">get与post请求有什么区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cookie%E3%80%81localStorage%E3%80%81sessionStorage%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">14.</span> <span class="toc-text">cookie、localStorage、sessionStorage的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#async-%E5%92%8C-await-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">15.</span> <span class="toc-text">async 和 await 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#js%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">16.</span> <span class="toc-text">js的数据类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#js%E7%9A%84%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="toc-number">17.</span> <span class="toc-text">js的变量提升</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#map%E5%92%8CforEach%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">18.</span> <span class="toc-text">map和forEach的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88"><span class="toc-number">19.</span> <span class="toc-text">项目性能优化方案</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="https://scarypig.github.io/myblog/myblog/2021/09/01/%E9%9D%A2%E8%AF%95/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Scay Pig"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="咕噜咕噜~~"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">前端面试题</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="创建时间：2021-09-01 20:38:09" itemprop="dateCreated datePublished" datetime="2021-09-01T20:38:09+08:00">2021-09-01</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-2-line"></span></span> <time title="修改时间：2023-05-08 17:08:37" itemprop="dateModified" datetime="2023-05-08T17:08:37+08:00">2023-05-08</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><span class="icon iconify" data-icon="ri:folder-line"></span></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/myblog/categories/%E5%AD%A6%E4%B9%A0/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">学习</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/myblog/tags/%E5%89%8D%E7%AB%AF/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">前端</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h1><p>在父元素高度没有定义下，由于浮动在标准流中不占空间，导致后面的标准流元素上移重复，此时要清楚浮动。</p>
<p>1.额外标签法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear: left/right/both</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;height: 60px;background-color: rgb(231, 23, 23);float: left;&quot;&gt;pig&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div style=&quot;clear: both;&quot;&gt;&lt;/div&gt;   清除浮动，标签必须是块级元素</span><br><span class="line"></span><br><span class="line">&lt;div style=&quot;background-color: violet;&quot;&gt;scaryp&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>2.父级添加overflow</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">overflow: hidden/auto/scroll</span><br></pre></td></tr></table></figure>

<p>3.after伪元素</p>
<p>父级添加该css属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:after &#123;</span><br><span class="line">	content: &quot;&quot;;</span><br><span class="line">	display: block;</span><br><span class="line">	height: 0;</span><br><span class="line">	clear: both;</span><br><span class="line">	visibility: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix &#123;</span><br><span class="line">	*zoom: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.双伪元素清楚浮动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:before,</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">	content: &quot;&quot;;</span><br><span class="line">	display: table;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">	clear: both;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix &#123;</span><br><span class="line">	*zoom: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h1><p><strong>防抖</strong>：触发事件后，在n秒内，事件只执行一次，如果在n秒内又触发了事件，则会重新计算函数的执行时间。</p>
<p>比如点击按钮，2秒后调用函数，结果在1.5秒的时候又点了，则会重新计算2秒后在调用函数。</p>
<p>应用场景：下拉触底加载下一页。</p>
<p><strong>节流</strong>：连续发生的事件在n秒内，只执行为一次</p>
<p>应用场景比较多的是：搜索查询</p>
<h1 id="js闭包"><a href="#js闭包" class="headerlink" title="js闭包"></a>js闭包</h1><p>闭包是指一个函数和对其周围状态的引用捆绑在一起），这样的组合就是<strong>闭包</strong>。</p>
<p>函数里面嵌套函数，得到突破函数的作用域的效果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">fun1</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">fun2</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fun2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> one = <span class="title function_">fun1</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">one</span>());</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<p>①保护函数内的变量安全 ，实现封装，防止变量流入其他环境发生命名冲突<br>②在内存中维持一个变量，可以做缓存（但使用多了同时也是一项缺点，消耗内存）。<br>③匿名自执行函数可以减少内存消耗。（function（）{}）{}</p>
<p>坏处：<br> ①被引用的私有变量不能被销毁，增大了内存消耗，造成内存泄漏，解决方法是可以在使用完变量后手动为它赋值为null。</p>
<p> ②其次由于闭包涉及跨域访问，所以会导致性能损失，我们可以通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响。</p>
<h1 id="vue中的data为什么是一个函数？"><a href="#vue中的data为什么是一个函数？" class="headerlink" title="vue中的data为什么是一个函数？"></a>vue中的data为什么是一个函数？</h1><p>当 data 是函数时，<strong>组件实例化</strong>的时候这个<strong>函数将会被调用</strong>，返回一个对象，计算机会给这个对象分配一个内存地址，实例化几次就分配几个内存地址，他们的地址都不一样，所以每个组件中的数据不会相互干扰，改变其中一个组件的状态，其它组件不变。</p>
<p>简单来说，就是为了保证组件的独立性和可复用性，如果 data 是个函数的话，每复用一次组件就会返回新的 data，类似于给每个组件实例创建一个私有的数据空间，保护各自的数据互不影响</p>
<h1 id="var-let-const-区别"><a href="#var-let-const-区别" class="headerlink" title="var let const 区别"></a>var let const 区别</h1><p><strong>var</strong>： </p>
<ol>
<li>存在变量提升；</li>
<li>存在变量覆盖，已经被定义且赋值的变量，如果再次被赋值，则以后一次值为准；</li>
<li>没有块级作用域；</li>
</ol>
<p><strong>const</strong>：</p>
<ol>
<li>定义的是常量，声明之后必须赋值；</li>
<li>定义的值不能去修改，否则报错；</li>
<li>有块级作用域；不存在变量提升和变量覆盖；</li>
<li>对于数组和对象的元素修改，不算做对常量的修改，不会报错。</li>
</ol>
<p><strong>let</strong>： </p>
<ol>
<li>有块级作用域；不存在变量提升和变量覆盖；</li>
<li>let不允许在相同的作用域中重复声明，注意是相同作用域，不同作用域重复声明不会报错</li>
</ol>
<h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>let a &#x3D; 1; let b &#x3D; 2; 如果在不声明第三个变量的前提下，使a&#x3D;2, b&#x3D;1？</p>
<p>答案：[a, b] &#x3D; [b, a]</p>
<p>如何利用es6快速的去重</p>
<p>let arr &#x3D; [23, 12, 13, 33, 22, 12, 21]</p>
<p>let item &#x3D; […new Set(arr)]</p>
<h1 id="MVC和MVVM的区别"><a href="#MVC和MVVM的区别" class="headerlink" title="MVC和MVVM的区别"></a>MVC和MVVM的区别</h1><p><strong>MVC</strong>：M（model数据）、V（view视图），C（controlle控制器）缺点是前后端无法独立开发，必须等后端接口做好了才可以往下走；前端没有自己的数据中心，太过依赖后台</p>
<p>MVVM：M（model数据）、V（view视图）、VM（viewModel控制数据的改变和控制视图）<br>html部分相当于View层，可以看到这里的View通过通过模板语法来声明式的将数据渲染进DOM元素，当ViewModel对Model进行更新时，通过数据绑定更新到View。 Vue实例中的data相当于Model层，而ViewModel层的核心是Vue中的双向数据绑定，即Model变化时VIew可以实时更新，View变化也能让Model发生变化</p>
<p>MVVM与MVC最大的区别就是：它实现了View和Model的自动同步，也就是当Model的属性改变时，我们不用再自己手动操作Dom元素，来改变View的显示，而是改变属性后该属性对应View层显示会自动改变</p>
<h1 id="v-model-原理"><a href="#v-model-原理" class="headerlink" title="v-model 原理"></a>v-model 原理</h1><p>是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调从而达到数据和视图同步。</p>
<h1 id="v-for中为什么要有key"><a href="#v-for中为什么要有key" class="headerlink" title="v-for中为什么要有key"></a>v-for中为什么要有key</h1><p>key 可以提高虚拟DOM的更新效率。</p>
<p>在vue中，默认“就地复用”的策略，在DOM操作的时候，如果没有key 就会造成选项错乱</p>
<p>key 只能是字符串或者number，其他类型不可以</p>
<h1 id="watch和computed的区别"><a href="#watch和computed的区别" class="headerlink" title="watch和computed的区别"></a>watch和computed的区别</h1><ol>
<li>computed是计算属性，依赖属性值发生变化，数据才会更新;watch监听数据变化,执行对应操</li>
<li>computed有缓存,当依赖的属性没有发生变化，则取缓存中的数据；watch监听值发生变化都会调用回调函数</li>
<li>computed必须有return,watch不需要</li>
<li>computed不能有异步，watch可以</li>
</ol>
<h1 id="vue组件之间的数据传递"><a href="#vue组件之间的数据传递" class="headerlink" title="vue组件之间的数据传递"></a>vue组件之间的数据传递</h1><p><strong>父组件给子组件传递数据</strong></p>
<p><img src="D:\blog\images\image-20230219223549655.png" alt="image-20230219223549655" loading="lazy"></p>
<p> <strong>子组件给父组件传递数据</strong></p>
<p>第一种：props</p>
<p><img src="D:\blog\images\image-20230219223709206.png" alt="image-20230219223709206" loading="lazy"></p>
<p><img src="D:\blog\images\image-20230219223716462.png" alt="image-20230219223716462" loading="lazy"></p>
<p>第二种：emit</p>
<p><img src="D:\blog\images\image-20230219224043869.png" alt="image-20230219224043869" loading="lazy"></p>
<p><img src="D:\blog\images\image-20230219224129060.png" alt="image-20230219224129060" loading="lazy"></p>
<p>第三种</p>
<p><img src="D:\blog\images\image-20230219224145056.png" alt="image-20230219224145056" loading="lazy"></p>
<p><img src="D:\blog\images\image-20230219224220379.png" alt="image-20230219224220379" loading="lazy"></p>
<h1 id="跨域的解决方法"><a href="#跨域的解决方法" class="headerlink" title="跨域的解决方法"></a>跨域的解决方法</h1><p>跨域：只要协议、域名和端口号有一个不相同就会产生跨域问题。同源策略是一个安全策略。同源，指的是协议，域名，端口相同。浏览器处于安全方面的考虑，只允许本域名下的接口交互，不同源的客户端脚本，在没有明确授权的情况下，不能读写对方的资源。</p>
<p>1.webpack 里的proxy</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    proxy: &#123;  //配置跨域</span><br><span class="line">      &#x27;/api&#x27;: &#123;</span><br><span class="line">        target: &#x27;http://121.121.67.254:8185/&#x27;,  //这里后台的地址模拟的;应该填写你们真实的后台接口</span><br><span class="line">        changOrigin: true,  //用于控制请求头中的post值，默认开启</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          /* 重写路径，当我们在浏览器中看到请求的地址为：http://localhost:8080/api/core/getData/userInfo 时</span><br><span class="line">            实际上访问的地址是：http://121.121.67.254:8185/core/getData/userInfo,因为重写了 /api</span><br><span class="line">           */</span><br><span class="line">          &#x27;^/api&#x27;: &#x27;&#x27; </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>2.jsonp （需要后端支持 ）</p>
<h1 id="get与post请求有什么区别"><a href="#get与post请求有什么区别" class="headerlink" title="get与post请求有什么区别"></a>get与post请求有什么区别</h1><p>get是从服务器上获取数据，post是向服务器传送数据。</p>
<p>POST比GET安全，因为数据在地址栏上不可见。</p>
<p>get方式提交的数据最多只能有1024字节，而post则没有此限制。</p>
<p>GET使用URL或Cookie传参。而POST将数据放在request BODY中。</p>
<p>GET与POST都有自己的语义，不能随便混用。</p>
<p>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基，本可以无视。而在网 络环境差的情况下，两次包的TCP在验证数据包完整 性上，有非常大的优点。post 发送两次，get 只发送一次。</p>
<h1 id="cookie、localStorage、sessionStorage的区别"><a href="#cookie、localStorage、sessionStorage的区别" class="headerlink" title="cookie、localStorage、sessionStorage的区别"></a>cookie、localStorage、sessionStorage的区别</h1><p><img src="D:\blog\images\image-20230219230159352.png" alt="image-20230219230159352" loading="lazy"></p>
<p>共同点: 都是保存在浏览器端、且同源的</p>
<p>不同点：</p>
<p>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。</p>
<p>存储大小限制也不同：</p>
<p>cookie数据不能超过4K，sessionStorage和localStorage可以达到5M</p>
<p>sessionStorage：仅在当前浏览器窗口关闭之前有效；</p>
<p>localStorage：始终有效，窗口或浏览器关闭也一直保存，本地存储，因此用作持久数据；</p>
<p>cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭</p>
<p>作用域不同</p>
<p>sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面；</p>
<p>localstorage：在所有同源窗口中都是共享的；也就是说只要浏览器不关闭，数据仍然存在</p>
<p>cookie: 也是在所有同源窗口中都是共享的.也就是说只要浏览器不关闭，数据仍然存在</p>
<h1 id="async-和-await-的区别"><a href="#async-和-await-的区别" class="headerlink" title="async 和 await 的区别"></a>async 和 await 的区别</h1><ul>
<li><p>async与await两种语法结合可以让异步代码像同步代码一样</p>
</li>
<li><p>async是定义异步函数，</p>
<p>1.返回值时promise对象；</p>
<p>2.对象的结果由函数执行的返回值决定</p>
</li>
<li><p>await</p>
<p>1.卸载async函数中；</p>
<p>2.后面跟的是任意表达式，一般使用promise的表达式；</p>
<p>3.当promise成功时，await返回的是promise成功的值；</p>
<p>4.await的promise失败时，就会抛出异常，需要通过try…catch捕获处理</p>
</li>
</ul>
<p>优点：async和await 属于es7语法。编写方便，提高程序效率，避免了回调地狱</p>
<p>补充：promise和async和await的区别</p>
<p>promise es6语法，promise中包含catch，async需要自己定义catch</p>
<p>promise 提供的方法会多一些，all、race等方法，aync中是没有的。</p>
<h1 id="js的数据类型"><a href="#js的数据类型" class="headerlink" title="js的数据类型"></a>js的数据类型</h1><p>js 数据类型分为基本数据类型和复杂数据类型</p>
<p>基本数据类型：Boolean、Number、String、Null、Undefined</p>
<p>复杂数据类型： Object、Array、Function、Date</p>
<h1 id="js的变量提升"><a href="#js的变量提升" class="headerlink" title="js的变量提升"></a>js的变量提升</h1><p>在js中，变量和函数的声明会被提升到最顶部执行</p>
<p>函数提升高于变量的提升</p>
<p>函数内部如果用var声明了相同名称的外部变量，函数将不再向上寻找</p>
<p>匿名函数不会提升</p>
<h1 id="map和forEach的区别"><a href="#map和forEach的区别" class="headerlink" title="map和forEach的区别"></a>map和forEach的区别</h1><p>forEach方法，是最基本的方法，遍历和循环。默认有3个参数：分别是遍历的每一个元素item，遍历的索引index，遍历的数组array</p>
<p>map方法，和foreach一致，不同的是会返回一个新的数组，所以callback需要有return返回值，如果没有会返回undefined</p>
<h1 id="项目性能优化方案"><a href="#项目性能优化方案" class="headerlink" title="项目性能优化方案"></a>项目性能优化方案</h1><p>减少http请求</p>
<p>减少DNS查询</p>
<p>使用CDN</p>
<p>避免重定向</p>
<p>图片懒加载</p>
<p>路由懒加载</p>
<p>减少DOM元素操作</p>
<p>使用外部js和css</p>
<p>压缩js、css、字体、图片等</p>
<p>使用iconfont字体图标、雪碧图等</p>
<p>避免图片的src为空</p>
<p>把样式表放在link中</p>
<p>把js放在页面的底部</p>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><span class="icon iconify" data-icon="ri:hand-coin-line"></span></span><div id="reward-comment">I'm so cute. Please give me money.</div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Scay Pig</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://scarypig.github.io/myblog/2021/09/01/%E9%9D%A2%E8%AF%95/" title="前端面试题">https://scarypig.github.io/myblog/2021/09/01/%E9%9D%A2%E8%AF%95/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/myblog/2021/09/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="prev" title="机器学习实战"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">机器学习实战</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/myblog/2021/06/19/JQuery/" rel="next" title="JQuery"><span class="post-nav-text">JQuery</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2023 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> Scay Pig</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v6.3.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.9</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></body></html>