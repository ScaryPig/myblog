<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="Scay Pig"><meta name="copyright" content="Scay Pig"><meta name="generator" content="Hexo 6.3.0"><meta name="theme" content="hexo-theme-yun"><title>postgreSQL源码 | 咕噜咕噜~~</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.4.1/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/myblog/yun.svg"><link rel="mask-icon" href="/myblog/yun.svg" color="#0078E7"><link rel="preload" href="/myblog/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/myblog/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"scarypig.github.io","root":"/myblog/","title":"春风十里不如你","version":"1.10.9","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"fireworks":{"colors":null},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/myblog/css/hexo-theme-yun.css"><script src="/myblog/js/hexo-theme-yun.js" type="module"></script><meta name="description" content="SQL执行流程：简单分为解析、查询优化、执行计划生成和执行这四步； 通过强转为Node类型可以查看数据自身类型  解释ctidctid表示数据记录的物理行当信息，表示表中的一条记录位于哪个数据块的哪个位置上。 ctid的形式为**(blockid,itemid)** 12345678lx&#x3D;# select ctid,* from demo3;  ctid  | name  | num1 | nu">
<meta property="og:type" content="article">
<meta property="og:title" content="postgreSQL源码">
<meta property="og:url" content="https://scarypig.github.io/myblog/2023/04/12/postgreSQL%E6%BA%90%E7%A0%81/index.html">
<meta property="og:site_name" content="咕噜咕噜~~">
<meta property="og:description" content="SQL执行流程：简单分为解析、查询优化、执行计划生成和执行这四步； 通过强转为Node类型可以查看数据自身类型  解释ctidctid表示数据记录的物理行当信息，表示表中的一条记录位于哪个数据块的哪个位置上。 ctid的形式为**(blockid,itemid)** 12345678lx&#x3D;# select ctid,* from demo3;  ctid  | name  | num1 | nu">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230407153956394.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230407154649886.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230407161150108.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230418132857940.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230418135715443.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230418135958795.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230418140929912.png">
<meta property="og:image" content="d:\blog\images\image-20230410152517503.png">
<meta property="og:image" content="d:\blog\images\image-20230410152617231.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230406100235521.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230406101314834.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230407151115123.png">
<meta property="article:published_time" content="2023-04-12T07:45:05.057Z">
<meta property="article:modified_time" content="2023-05-09T06:10:35.513Z">
<meta property="article:author" content="Scay Pig">
<meta property="article:tag" content="pgsql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230407153956394.png"><script>(function() {
  if (CONFIG.mode !== 'auto') return
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/myblog/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/myblog/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/myblog/about/" title="Scay Pig"><img width="96" loading="lazy" src="/myblog/yun.png" alt="Scay Pig"></a><div class="site-author-name"><a href="/myblog/about/">Scay Pig</a></div><span class="site-name">咕噜咕噜~~</span><sub class="site-subtitle"></sub><div class="site-description"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/myblog/" title="首页"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/myblog/archives/" title="归档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">47</span></a></div><div class="site-state-item"><a href="/myblog/categories/" title="分类"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">1</span></a></div><div class="site-state-item"><a href="/myblog/tags/" title="标签"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">20</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:settings-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/ScaryPig" title="GitHub" target="_blank" style="color:#6e5494"><span class="icon iconify" data-icon="ri:github-line"></span></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/myblog/links/" title="我的小伙伴们" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A"><span class="toc-number">1.</span> <span class="toc-text">解释</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ctid"><span class="toc-number">1.1.</span> <span class="toc-text">ctid</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%8F"><span class="toc-number">2.</span> <span class="toc-text">宏</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">3.</span> <span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BTMetaPageDaata"><span class="toc-number">3.1.</span> <span class="toc-text">BTMetaPageDaata</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BTPageOpaqueData"><span class="toc-number">3.2.</span> <span class="toc-text">BTPageOpaqueData</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BTPageState"><span class="toc-number">3.3.</span> <span class="toc-text">BTPageState</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BTWriteState"><span class="toc-number">3.4.</span> <span class="toc-text">BTWriteState</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BTScanOpaqueData"><span class="toc-number">3.5.</span> <span class="toc-text">BTScanOpaqueData</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RawStmt"><span class="toc-number">3.6.</span> <span class="toc-text">RawStmt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List"><span class="toc-number">3.7.</span> <span class="toc-text">List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PlannedStmt"><span class="toc-number">3.8.</span> <span class="toc-text">PlannedStmt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RelOptInfo"><span class="toc-number">3.9.</span> <span class="toc-text">RelOptInfo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Path"><span class="toc-number">3.10.</span> <span class="toc-text">Path</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PageHeaderData"><span class="toc-number">3.11.</span> <span class="toc-text">PageHeaderData</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ItemIdData"><span class="toc-number">3.12.</span> <span class="toc-text">ItemIdData</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HeapTupleHeaderData"><span class="toc-number">3.13.</span> <span class="toc-text">HeapTupleHeaderData</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RelationData"><span class="toc-number">3.14.</span> <span class="toc-text">RelationData</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IndexAmRoutine"><span class="toc-number">3.15.</span> <span class="toc-text">IndexAmRoutine</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IndexTupleData"><span class="toc-number">3.16.</span> <span class="toc-text">IndexTupleData</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tuplesortstate"><span class="toc-number">3.17.</span> <span class="toc-text">Tuplesortstate</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TupSortStatus"><span class="toc-number">3.17.1.</span> <span class="toc-text">TupSortStatus</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TIDBitmap"><span class="toc-number">3.18.</span> <span class="toc-text">TIDBitmap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IndexScanDescData"><span class="toc-number">3.19.</span> <span class="toc-text">IndexScanDescData</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashPageOpaqueData"><span class="toc-number">3.20.</span> <span class="toc-text">HashPageOpaqueData</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMetaPageData"><span class="toc-number">3.21.</span> <span class="toc-text">HashMetaPageData</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MemoryContext"><span class="toc-number">3.22.</span> <span class="toc-text">MemoryContext</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ScanKey"><span class="toc-number">3.23.</span> <span class="toc-text">ScanKey</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#parsetree"><span class="toc-number">5.</span> <span class="toc-text">parsetree</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#querytree"><span class="toc-number">6.</span> <span class="toc-text">querytree</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#plantree"><span class="toc-number">7.</span> <span class="toc-text">plantree</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%B7%AF%E5%BE%84%E7%94%9F%E6%88%90"><span class="toc-number">8.</span> <span class="toc-text">索引路径生成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#create-index-paths"><span class="toc-number">8.1.</span> <span class="toc-text">create_index_paths</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">9.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#index-create"><span class="toc-number">9.1.</span> <span class="toc-text">index_create</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#btbuild"><span class="toc-number">9.2.</span> <span class="toc-text">btbuild</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bt-spools-heapscan"><span class="toc-number">9.2.1.</span> <span class="toc-text">_bt_spools_heapscan</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bt-leafbuild"><span class="toc-number">9.2.2.</span> <span class="toc-text">_bt_leafbuild</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bt-load"><span class="toc-number">9.2.2.1.</span> <span class="toc-text">_bt_load</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bt-uppershutdown"><span class="toc-number">9.2.2.2.</span> <span class="toc-text">_bt_uppershutdown</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#l-bt-blwritepage"><span class="toc-number">9.2.2.2.1.</span> <span class="toc-text">l_bt_blwritepage</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#btinsert"><span class="toc-number">9.3.</span> <span class="toc-text">btinsert</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bt-doinsert"><span class="toc-number">9.3.1.</span> <span class="toc-text">_bt_doinsert</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#btbeginscan"><span class="toc-number">9.4.</span> <span class="toc-text">btbeginscan</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#btrescan"><span class="toc-number">9.5.</span> <span class="toc-text">btrescan</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#btgettuple"><span class="toc-number">9.6.</span> <span class="toc-text">btgettuple</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashbuild"><span class="toc-number">9.7.</span> <span class="toc-text">hashbuild</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hashbuildCallback"><span class="toc-number">9.7.1.</span> <span class="toc-text">hashbuildCallback</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hash-doinsert"><span class="toc-number">9.7.1.1.</span> <span class="toc-text">_hash_doinsert</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="https://scarypig.github.io/myblog/myblog/2023/04/12/postgreSQL%E6%BA%90%E7%A0%81/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Scay Pig"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="咕噜咕噜~~"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">postgreSQL源码</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="创建时间：2023-04-12 15:45:05" itemprop="dateCreated datePublished" datetime="2023-04-12T15:45:05+08:00">2023-04-12</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-2-line"></span></span> <time title="修改时间：2023-05-09 14:10:35" itemprop="dateModified" datetime="2023-05-09T14:10:35+08:00">2023-05-09</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><span class="icon iconify" data-icon="ri:folder-line"></span></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/myblog/categories/%E5%AD%A6%E4%B9%A0/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">学习</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/myblog/tags/pgsql/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">pgsql</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><ul>
<li>SQL执行流程：简单分为解析、查询优化、执行计划生成和执行这四步；</li>
<li>通过强转为Node类型可以查看数据自身类型</li>
</ul>
<h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><h2 id="ctid"><a href="#ctid" class="headerlink" title="ctid"></a>ctid</h2><p>ctid表示数据记录的物理行当信息，表示表中的一条记录位于<strong>哪个数据块</strong>的<strong>哪个位置</strong>上。</p>
<p>ctid的形式为**(blockid,itemid)**</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lx<span class="operator">=</span># <span class="keyword">select</span> ctid,<span class="operator">*</span> <span class="keyword">from</span> demo3;</span><br><span class="line">  ctid  <span class="operator">|</span> name  <span class="operator">|</span> num1 <span class="operator">|</span> num2</span><br><span class="line"><span class="comment">--------+-------+------+------</span></span><br><span class="line"> (<span class="number">0</span>,<span class="number">24</span>) <span class="operator">|</span> zhang <span class="operator">|</span>   <span class="number">13</span> <span class="operator">|</span>   <span class="number">14</span></span><br><span class="line"> (<span class="number">0</span>,<span class="number">25</span>) <span class="operator">|</span> zhang <span class="operator">|</span>   <span class="number">32</span> <span class="operator">|</span>  <span class="number">423</span></span><br><span class="line"> (<span class="number">0</span>,<span class="number">26</span>) <span class="operator">|</span> li    <span class="operator">|</span>  <span class="number">322</span> <span class="operator">|</span>   <span class="number">23</span></span><br><span class="line"> (<span class="number">0</span>,<span class="number">27</span>) <span class="operator">|</span> zhang <span class="operator">|</span> <span class="number">5452</span> <span class="operator">|</span>    <span class="number">3</span></span><br><span class="line">(<span class="number">4</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>



<p>delete数据后空间不会释放，执行vacuum将以删除数据的空间释放</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lx=# vacuum demo3;</span><br><span class="line"></span><br><span class="line">lx=# insert into demo3 values(&#x27;liu&#x27;,101,25);</span><br><span class="line">INSERT 0 1</span><br><span class="line">lx=# select ctid,* from demo3;</span><br><span class="line">  ctid  | name  | num1 | num2</span><br><span class="line">--------+-------+------+------</span><br><span class="line"> (0,1)  | liu   |  101 |   25</span><br><span class="line"> (0,24) | zhang |   13 |   14</span><br><span class="line"> (0,25) | zhang |   32 |  423</span><br><span class="line"> (0,26) | li    |  322 |   23</span><br><span class="line"> (0,27) | zhang | 5452 |    3</span><br><span class="line"> (0,28) | liu   |   13 |   14</span><br><span class="line">(6 rows)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>通过pg_class可以查看一个表的所有块数和记录数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lx=# select relpages,reltuples from pg_class where relname = &#x27;demo3&#x27;;</span><br><span class="line"> relpages | reltuples</span><br><span class="line">----------+-----------</span><br><span class="line">        1 |         5</span><br><span class="line">(1 row)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#define GIN_SUPPORT(type, is_varlena, leftmostvalue, typecmp)				\</span><br><span class="line">PG_FUNCTION_INFO_V1(gin_extract_value_##type);								\</span><br><span class="line">Datum																		\</span><br><span class="line">gin_extract_value_##type(PG_FUNCTION_ARGS)									\</span><br><span class="line">&#123;																			\</span><br><span class="line">	return gin_btree_extract_value(fcinfo, is_varlena);						\</span><br><span class="line">&#125;	\</span><br><span class="line">PG_FUNCTION_INFO_V1(gin_extract_query_##type);								\</span><br><span class="line">Datum																		\</span><br><span class="line">gin_extract_query_##type(PG_FUNCTION_ARGS)									\</span><br><span class="line">&#123;																			\</span><br><span class="line">	return gin_btree_extract_query(fcinfo,									\</span><br><span class="line">								   is_varlena, leftmostvalue, typecmp);		\</span><br><span class="line">&#125;	\</span><br><span class="line">PG_FUNCTION_INFO_V1(gin_compare_prefix_##type);								\</span><br><span class="line">Datum																		\</span><br><span class="line">gin_compare_prefix_##type(PG_FUNCTION_ARGS)									\</span><br><span class="line">&#123;																			\</span><br><span class="line">	return gin_btree_compare_prefix(fcinfo);								\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是一个宏定义，它定义了一组函数来支持GIN索引类型的操作。GIN是一种高性能的索引结构，可以用于处理包含多个元素的复杂数据类型，例如数组或JSON对象。</p>
<p>具体来说，这个宏定义了以下函数：</p>
<ul>
<li>gin_extract_value_#type：从GIN索引中提取值，并将其转换为特定的数据类型#type。这个函数在执行GIN扫描时被调用。</li>
<li>gin_extract_query_#type：从查询中提取值，并将其转换为特定的数据类型#type。这个函数在执行GIN查询时被调用。</li>
<li>gin_compare_prefix_#type：比较索引中的值和查询中的前缀，以确定它们是否匹配。这个函数在执行GIN前缀查询时被调用。</li>
</ul>
<p>在这个宏中，#type是一个占位符，代表特定的数据类型，例如int、float、text等。这个宏还包括一些其他参数，例如is_varlena、leftmostvalue和typecmp，它们用于指定数据类型的特定属性和比较函数。</p>
<p>这些函数都被声明为PG_FUNCTION_INFO_V1宏的参数，这是一个宏，用于指定函数的元数据。这些函数都返回一个Datum类型的值，这是PostgreSQL中用于表示任意数据类型的通用数据类型。</p>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h2 id="BTMetaPageDaata"><a href="#BTMetaPageDaata" class="headerlink" title="BTMetaPageDaata"></a>BTMetaPageDaata</h2><ul>
<li>记录btree根节点所在page的位置</li>
<li>叶子节点所在层数为0层，根所在n层</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230407153956394.png" alt="image-20230407153956394" loading="lazy"></p>
<h2 id="BTPageOpaqueData"><a href="#BTPageOpaqueData" class="headerlink" title="BTPageOpaqueData"></a>BTPageOpaqueData</h2><p>存放在每个页面的页尾，位于Special中</p>
<p><img src="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230407154649886.png" alt="image-20230407154649886" loading="lazy"></p>
<h2 id="BTPageState"><a href="#BTPageState" class="headerlink" title="BTPageState"></a>BTPageState</h2><p>记录建树过程中，创建的每个结点页信息</p>
<p><img src="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230407161150108.png" alt="image-20230407161150108" loading="lazy"></p>
<h2 id="BTWriteState"><a href="#BTWriteState" class="headerlink" title="BTWriteState"></a>BTWriteState</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTWriteState</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	Relation	heap;</span><br><span class="line">	Relation	index;</span><br><span class="line">	BTScanInsert inskey;		<span class="comment">/* generic insertion scankey */</span></span><br><span class="line">	<span class="type">bool</span>		btws_use_wal;	<span class="comment">/* 是否开启了WAL */</span></span><br><span class="line">	BlockNumber btws_pages_alloced; <span class="comment">/* 索引下一次申请page时的块号 */</span></span><br><span class="line">	BlockNumber btws_pages_written; <span class="comment">/* 已经写入文件的页面块号 */</span></span><br><span class="line">	Page		btws_zeropage;	<span class="comment">/* 需要填充0值的页面 */</span></span><br><span class="line">&#125; BTWriteState;</span><br></pre></td></tr></table></figure>

<h2 id="BTScanOpaqueData"><a href="#BTScanOpaqueData" class="headerlink" title="BTScanOpaqueData"></a>BTScanOpaqueData</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTScanOpaqueData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">/* these fields are set by _bt_preprocess_keys(): */</span></span><br><span class="line">	<span class="type">bool</span>		qual_ok;		<span class="comment">/* false if qual can never be satisfied */</span></span><br><span class="line">	<span class="type">int</span>			numberOfKeys;	<span class="comment">/* number of preprocessed scan keys */</span></span><br><span class="line">	ScanKey		keyData;		<span class="comment">/* array of preprocessed scan keys */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* workspace for SK_SEARCHARRAY support */</span></span><br><span class="line">	ScanKey		arrayKeyData;	<span class="comment">/* modified copy of scan-&gt;keyData */</span></span><br><span class="line">	<span class="type">int</span>			numArrayKeys;	<span class="comment">/* number of equality-type array keys (-1 if</span></span><br><span class="line"><span class="comment">								 * there are any unsatisfiable array keys) */</span></span><br><span class="line">	<span class="type">int</span>			arrayKeyCount;	<span class="comment">/* count indicating number of array scan keys</span></span><br><span class="line"><span class="comment">								 * processed */</span></span><br><span class="line">	BTArrayKeyInfo *arrayKeys;	<span class="comment">/* info about each equality-type array key */</span></span><br><span class="line">	MemoryContext arrayContext; <span class="comment">/* scan-lifespan context for array data */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* info about killed items if any (killedItems is NULL if never used) */</span></span><br><span class="line">	<span class="type">int</span>		   *killedItems;	<span class="comment">/* currPos.items indexes of killed items */</span></span><br><span class="line">	<span class="type">int</span>			numKilled;		<span class="comment">/* number of currently stored items */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we are doing an index-only scan, these are the tuple storage</span></span><br><span class="line"><span class="comment">	 * workspaces for the currPos and markPos respectively.  Each is of size</span></span><br><span class="line"><span class="comment">	 * BLCKSZ, so it can hold as much as a full page&#x27;s worth of tuples.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span>	   *currTuples;		<span class="comment">/* tuple storage for currPos */</span></span><br><span class="line">	<span class="type">char</span>	   *markTuples;		<span class="comment">/* tuple storage for markPos */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the marked position is on the same page as current position, we</span></span><br><span class="line"><span class="comment">	 * don&#x27;t use markPos, but just keep the marked itemIndex in markItemIndex</span></span><br><span class="line"><span class="comment">	 * (all the rest of currPos is valid for the mark position). Hence, to</span></span><br><span class="line"><span class="comment">	 * determine if there is a mark, first look at markItemIndex, then at</span></span><br><span class="line"><span class="comment">	 * markPos.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span>			markItemIndex;	<span class="comment">/* itemIndex, or -1 if not valid */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* keep these last in struct for efficiency */</span></span><br><span class="line">	BTScanPosData currPos;		<span class="comment">/* current position data */</span></span><br><span class="line">	BTScanPosData markPos;		<span class="comment">/* marked position, if any */</span></span><br><span class="line">&#125; BTScanOpaqueData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> BTScanOpaqueData *BTScanOpaque;</span><br></pre></td></tr></table></figure>

<h2 id="RawStmt"><a href="#RawStmt" class="headerlink" title="RawStmt"></a>RawStmt</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct RawStmt</span><br><span class="line">&#123;</span><br><span class="line">	NodeTag		type;</span><br><span class="line">	Node	   *stmt;			/* 节点内容 */</span><br><span class="line">	int			stmt_location;	/* start location, or -1 if unknown */</span><br><span class="line">	int			stmt_len;		/* length in bytes; 0 means &quot;rest of string&quot; */</span><br><span class="line">&#125; RawStmt;</span><br></pre></td></tr></table></figure>

<p>SelectStmt</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct SelectStmt</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	List	   *valuesLists;	// values()内的值</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125; SelectStmt;</span><br></pre></td></tr></table></figure>

<p>InsertStmt</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct InsertStmt</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	Node	   *selectStmt;		// 存放数据来源，values()内 || select得到 || Null</span><br><span class="line">	...</span><br><span class="line">&#125; InsertStmt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct List</span><br><span class="line">&#123;</span><br><span class="line">	NodeTag		type;			/* 节点类型 */</span><br><span class="line">	int			length;			/* 链表长度 */</span><br><span class="line">	int			max_length;		/* allocated length of elements[] */</span><br><span class="line">	ListCell   *elements;		/* re-allocatable array of cells */</span><br><span class="line">	/* We may allocate some cells along with the List header: */</span><br><span class="line">	ListCell	initial_elements[FLEXIBLE_ARRAY_MEMBER];</span><br><span class="line">	/* If elements == initial_elements, it&#x27;s not a separate allocation */</span><br><span class="line">&#125; List;</span><br></pre></td></tr></table></figure>

<p>ListCell</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef union ListCell</span><br><span class="line">&#123;</span><br><span class="line">	void	   *ptr_value;</span><br><span class="line">	int			int_value;</span><br><span class="line">	Oid			oid_value;</span><br><span class="line">&#125; ListCell;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h2 id="PlannedStmt"><a href="#PlannedStmt" class="headerlink" title="PlannedStmt"></a>PlannedStmt</h2><p><img src="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230418132857940.png" alt="image-20230418132857940" loading="lazy"></p>
<h2 id="RelOptInfo"><a href="#RelOptInfo" class="headerlink" title="RelOptInfo"></a>RelOptInfo</h2><p><img src="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230418135715443.png" alt="image-20230418135715443" loading="lazy"><img src="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230418135958795.png" alt="image-20230418135958795" loading="lazy"></p>
<h2 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h2><p><img src="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230418140929912.png" alt="image-20230418140929912" loading="lazy"></p>
<h2 id="PageHeaderData"><a href="#PageHeaderData" class="headerlink" title="PageHeaderData"></a>PageHeaderData</h2><p>长度为20字节</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PageHeaderData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">/* XXX LSN is member of *any* block, not only page-organized ones */</span></span><br><span class="line">	PageXLogRecPtr pd_lsn;		<span class="comment">/* LSN: next byte after last byte of xlog</span></span><br><span class="line"><span class="comment">								 * record for last change to this page */</span></span><br><span class="line">	uint16		pd_checksum;	<span class="comment">/* checksum */</span></span><br><span class="line">	uint16		pd_flags;		<span class="comment">/* flag bits, see below */</span></span><br><span class="line">	LocationIndex pd_lower;		<span class="comment">/* free space开始的偏移量 */</span></span><br><span class="line">	LocationIndex pd_upper;		<span class="comment">/* of free space结束的偏移量 */</span></span><br><span class="line">	LocationIndex pd_special;	<span class="comment">/* special space的偏移量 */</span></span><br><span class="line">	uint16		pd_pagesize_version;</span><br><span class="line">	TransactionId pd_prune_xid; <span class="comment">/* oldest prunable XID, or zero if none */</span></span><br><span class="line">	ItemIdData	pd_linp[FLEXIBLE_ARRAY_MEMBER]; <span class="comment">/* line pointer array */</span></span><br><span class="line">&#125; PageHeaderData;</span><br></pre></td></tr></table></figure>

<h2 id="ItemIdData"><a href="#ItemIdData" class="headerlink" title="ItemIdData"></a>ItemIdData</h2><p>ItemIdData用来保存数据块的linp项指针数据，每个linp指向一个块内元组，长度为4字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct ItemIdData</span><br><span class="line">&#123;</span><br><span class="line">	unsigned	lp_off:15,		/* 元组在文件块中的偏移量 */</span><br><span class="line">				lp_flags:2,		/* 元组状态（未使用、正常使用、HOT重定向和死亡） */</span><br><span class="line">				lp_len:15;		/* 该元组的长度 */</span><br><span class="line">&#125; ItemIdData;</span><br></pre></td></tr></table></figure>

<h2 id="HeapTupleHeaderData"><a href="#HeapTupleHeaderData" class="headerlink" title="HeapTupleHeaderData"></a>HeapTupleHeaderData</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapTupleHeaderData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		HeapTupleFields t_heap;	<span class="comment">// 记录对元组进行操作的事务ID与命令ID</span></span><br><span class="line">		DatumTupleFields t_datum;	<span class="comment">// 记录元组的长度等信息</span></span><br><span class="line">	&#125;			t_choice;</span><br><span class="line"></span><br><span class="line">	ItemPointerData t_ctid;		<span class="comment">/* 记录当前元组或新元组的物理位置（块内偏移量和元组长度） */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Fields below here must match MinimalTupleData! */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIELDNO_HEAPTUPLEHEADERDATA_INFOMASK2 2</span></span><br><span class="line">	uint16		t_infomask2;	<span class="comment">/* number of attributes + various flags */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIELDNO_HEAPTUPLEHEADERDATA_INFOMASK 3</span></span><br><span class="line">	uint16		t_infomask;		<span class="comment">/* 标识元组当前状态 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIELDNO_HEAPTUPLEHEADERDATA_HOFF 4</span></span><br><span class="line">	uint8		t_hoff;			<span class="comment">/* 该元组头的大小 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ^ - 23 bytes - ^ */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIELDNO_HEAPTUPLEHEADERDATA_BITS 5</span></span><br><span class="line">	bits8		t_bits[FLEXIBLE_ARRAY_MEMBER];	<span class="comment">/* bitmap of NULLs */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* MORE DATA FOLLOWS AT END OF STRUCT */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="RelationData"><a href="#RelationData" class="headerlink" title="RelationData"></a>RelationData</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RelationData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">RelFileNode rd_node;		<span class="comment">//关系(表)的物理标识符，包含了表空间、数据库和表的OID</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SMgrRelationData</span> *<span class="title">rd_smgr</span>;</span>	<span class="comment">//用于缓存关系(表)的文件句柄，如果没有则为NULL</span></span><br><span class="line"></span><br><span class="line">Form_pg_class rd_rel;		<span class="comment">//关系(表)在系统表pg_class中对应的元组里的信息</span></span><br><span class="line">TupleDesc	rd_att;			<span class="comment">//关系(表)的元组描述符，即表的列名和相关信息。</span></span><br><span class="line">Oid			rd_id;			<span class="comment">///关系(表)的OID</span></span><br><span class="line">RuleLock   *rd_rules;		<span class="comment">//关系(表)的重写规则</span></span><br><span class="line">MemoryContext rd_rulescxt;	<span class="comment">//重写规则的私有内存上下文</span></span><br><span class="line">TriggerDesc *trigdesc;		<span class="comment">//关系(表)的触发器的相关信息，如果没有则为NULL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RowSecurityDesc</span> *<span class="title">rd_rsdesc</span>;</span>	<span class="comment">//行的安全策略，如果没有则为NULL</span></span><br><span class="line"></span><br><span class="line">List	   *rd_fkeylist;	<span class="comment">//外键缓存信息的链表</span></span><br><span class="line"><span class="type">bool</span>		rd_fkeyvalid;	<span class="comment">//如果链表已经生成则为真</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PartitionKeyData</span> *<span class="title">rd_partkey</span>;</span>	<span class="comment">//用于分片的关键字</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PartitionDescData</span> *<span class="title">rd_partdesc</span>;</span>	<span class="comment">//分片的描述符</span></span><br><span class="line"></span><br><span class="line">List	   *rd_indexlist;	<span class="comment">//关系(表)上所有索引的OID链表</span></span><br><span class="line">Oid			rd_pkindex;		<span class="comment">//主键的OID</span></span><br><span class="line"></span><br><span class="line">Bitmapset  *rd_indexattr;	<span class="comment">//记录上面的re_indexlist中各个索引用到的列名</span></span><br><span class="line">Bitmapset  *rd_keyattr;		<span class="comment">//记录外键的映射</span></span><br><span class="line">Bitmapset  *rd_pkattr;		<span class="comment">//记录主键中包含的列名</span></span><br><span class="line">Form_pg_index rd_index;		<span class="comment">//如果该表是一个索引表，这里用于记录它在pg_index中的信息。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapTupleData</span> *<span class="title">rd_indextuple</span>;</span>	<span class="comment">//同上，记录表在pg_index中的的所有元组。</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">Oid			rd_toastoid;	<span class="comment">//toast表的oid，不存在则为invaildOid</span></span><br><span class="line"><span class="type">void</span>	   *rd_amcache;		<span class="comment">/* 让索引/表AM使用 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PgStat_TableStatus</span> *<span class="title">pgstat_info</span>;</span> <span class="comment">//统计信息集合</span></span><br><span class="line">&#125; RelationData;</span><br></pre></td></tr></table></figure>

<h2 id="IndexAmRoutine"><a href="#IndexAmRoutine" class="headerlink" title="IndexAmRoutine"></a>IndexAmRoutine</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">typedef struct IndexAmRoutine</span><br><span class="line">&#123;</span><br><span class="line">    NodeTag     type;</span><br><span class="line"></span><br><span class="line">    /* * 我们可以遍历/搜索 * 这个 AM 的策略（运算符）总数。如果 AM 没有一组固定的策略分配，则为零。*/</span><br><span class="line">    uint16      amstrategies;</span><br><span class="line">    /* 此 AM 使用的支持函数总数 */</span><br><span class="line">    uint16      amsupport;</span><br><span class="line">    /* opclass 选项支持函数号或 0 */</span><br><span class="line">    uint16      amoptsprocnum;</span><br><span class="line">    /* AM 是否支持 ORDER BY 索引列的值？*/</span><br><span class="line">    bool        amcanorder;</span><br><span class="line">    /* AM 是否支持索引列上的运算符的 ORDER BY 结果？*/</span><br><span class="line">    bool        amcanorderbyop;</span><br><span class="line">    /* AM是否支持反向扫描？*/</span><br><span class="line">    bool        amcanbackward;</span><br><span class="line">    /* AM 是否支持 UNIQUE 索引？*/</span><br><span class="line">    bool        amcanunique;</span><br><span class="line">    /* AM 是否支持多列索引？*/</span><br><span class="line">    bool        amcanmulticol;</span><br><span class="line">    /* AM 是否要求扫描对第一个索引列有约束？*/</span><br><span class="line">    bool        amoptionalkey;</span><br><span class="line">    /* AM 处理 ScalarArrayOpExpr quals 吗？*/</span><br><span class="line">    bool        amsearcharray;</span><br><span class="line">    /* AM 处理 IS NULL/IS NOT NULL quals 吗？*/</span><br><span class="line">    bool        amsearchnulls;</span><br><span class="line">    /* 索引存储数据类型可以与列数据类型不同吗？*/</span><br><span class="line">    bool        amstorage;</span><br><span class="line">    /* 这种类型的索引可以聚集在上面吗？*/</span><br><span class="line">    bool        amclusterable;</span><br><span class="line">    /* AM 处理谓词锁吗？*/</span><br><span class="line">    bool        ampredlocks;</span><br><span class="line">    /* AM是否支持并行扫描？*/</span><br><span class="line">    bool        amcanparallel;</span><br><span class="line">    /* AM 是否支持包含在子句 INCLUDE 中的列？*/</span><br><span class="line">    bool        amcaninclude;</span><br><span class="line">    /* AM是否使用maintenance_work_mem？*/</span><br><span class="line">    bool        amusemaintenanceworkmem;</span><br><span class="line">    /* 并行真空标志的 OR */</span><br><span class="line">    uint8       amparallelvacuumoptions;</span><br><span class="line">    /* 存储在索引中的数据类型，如果变量是 InvalidOid */</span><br><span class="line">    Oid         amkeytype;</span><br><span class="line"></span><br><span class="line">    /* 接口函数 */</span><br><span class="line">    ambuild_function ambuild;</span><br><span class="line">    ambuildempty_function ambuildempty;</span><br><span class="line">    aminsert_function aminsert;</span><br><span class="line">    ambulkdelete_function ambulkdelete;</span><br><span class="line">    amvacuumcleanup_function amvacuumcleanup;</span><br><span class="line">    amcanreturn_function amcanreturn;   /* 可以为 NULL */</span><br><span class="line">    amcostestimate_function amcostestimate;</span><br><span class="line">    amoptions_function amoptions;</span><br><span class="line">    amproperty_function amproperty;     /* 可以为 NULL */</span><br><span class="line">    ambuildphasename_function ambuildphasename;   /* 可以为 NULL */</span><br><span class="line">    amvalidate_function amvalidate;</span><br><span class="line">    amadjustmembers_function amadjustmembers; /* 可以为 NULL */</span><br><span class="line">    ambeginscan_function ambeginscan;</span><br><span class="line">    amrescan_function amrescan;</span><br><span class="line">    amgettuple_function amgettuple;     /* 可以为 NULL */</span><br><span class="line">    amgetbitmap_function amgetbitmap;   /* 可以为 NULL */</span><br><span class="line">    amendscan_function amendscan;</span><br><span class="line">    ammarkpos_function ammarkpos;       /* 可以为 NULL */</span><br><span class="line">    amrestrpos_function amrestrpos;     /* 可以为 NULL */</span><br><span class="line"></span><br><span class="line">    /* 支持并行索引扫描的接口函数 */</span><br><span class="line">    amestimateparallelscan_function amestimateparallelscan;    /* 可以为 NULL */</span><br><span class="line">    aminitparallelscan_function aminitparallelscan;    /* 可以为 NULL */</span><br><span class="line">    amparallelrescan_function amparallelrescan;    /* 可以为 NULL */</span><br><span class="line">&#125; IndexAmRoutine;</span><br></pre></td></tr></table></figure>

<h2 id="IndexTupleData"><a href="#IndexTupleData" class="headerlink" title="IndexTupleData"></a>IndexTupleData</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IndexTupleData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ItemPointerData t_tid;		<span class="comment">/* reference TID to heap tuple */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> t_info;		<span class="comment">/* various info about tuple */</span></span><br><span class="line"></span><br><span class="line">&#125; IndexTupleData;	</span><br></pre></td></tr></table></figure>

<h2 id="Tuplesortstate"><a href="#Tuplesortstate" class="headerlink" title="Tuplesortstate"></a>Tuplesortstate</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tuplesortstate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	TupSortStatus status;		<span class="comment">// 枚举状态，详情见下面</span></span><br><span class="line">	<span class="type">int</span>			nKeys;			<span class="comment">// sort key中的列数</span></span><br><span class="line">	<span class="type">int</span>			sortopt;		<span class="comment">/* Bitmask of flags used to setup sort */</span></span><br><span class="line">	<span class="type">bool</span>		bounded;		<span class="comment">// 调用者是否指定了最大返回的元组的数目</span></span><br><span class="line">	<span class="type">bool</span>		boundUsed;		<span class="comment">// 使用有界堆,则返回T</span></span><br><span class="line">	<span class="type">int</span>			bound;			<span class="comment">// 如为有界堆,这里存储最大的元组个数</span></span><br><span class="line">	<span class="type">bool</span>		tuples;			<span class="comment">// SortTuple.tuple是否可以设置</span></span><br><span class="line">	int64		availMem;		<span class="comment">// 剩余可用内存大小(单位:字节)</span></span><br><span class="line">	int64		allowedMem;		<span class="comment">// 允许的内存总大小(单位:字节)</span></span><br><span class="line">	<span class="type">int</span>			maxTapes;		<span class="comment">// tapes个数</span></span><br><span class="line">	int64		maxSpace;		<span class="comment">// tapes个数 - 1</span></span><br><span class="line">	<span class="type">bool</span>		isMaxSpaceDisk;</span><br><span class="line">	TupSortStatus maxSpaceStatus;	<span class="comment">/* sort status when maxSpace was reached */</span></span><br><span class="line">	MemoryContext maincontext;	<span class="comment">/* memory context for tuple sort metadata that</span></span><br><span class="line"><span class="comment">								 * persists across multiple batches */</span></span><br><span class="line">	MemoryContext sortcontext;	<span class="comment">// 主要用于排序数据的内存上下文</span></span><br><span class="line">	MemoryContext tuplecontext; <span class="comment">// 用于元组数据的sortcontext的子上下文</span></span><br><span class="line">	LogicalTapeSet *tapeset;	<span class="comment">// 临时文件中tapes的logtape.c对象</span></span><br><span class="line"></span><br><span class="line">	SortTupleComparator comparetup;</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>		(*copytup) (Tuplesortstate *state, SortTuple *stup, <span class="type">void</span> *tup);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>		(*writetup) (Tuplesortstate *state, LogicalTape *tape,</span><br><span class="line">							 SortTuple *stup);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>		(*readtup) (Tuplesortstate *state, SortTuple *stup,</span><br><span class="line">							LogicalTape *tape, <span class="type">unsigned</span> <span class="type">int</span> len);</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span>		haveDatum1;</span><br><span class="line"></span><br><span class="line">    *******************************************************************</span><br><span class="line">	SortTuple  *memtuples;		<span class="comment">// SortTuple结构体数组，里面存放了读取的数据</span></span><br><span class="line">	<span class="type">int</span>			memtupcount;	<span class="comment">// 当前存在的元组数</span></span><br><span class="line">    *******************************************************************</span><br><span class="line">	<span class="type">int</span>			memtupsize;		<span class="comment">// memtuples数组的已分配的大小</span></span><br><span class="line">	<span class="type">bool</span>		growmemtuples;	<span class="comment">// memtuples的增长仍在进行中?</span></span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span>		slabAllocatorUsed;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span>	   *slabMemoryBegin;	<span class="comment">// slab内存空间的起始位置</span></span><br><span class="line">	<span class="type">char</span>	   *slabMemoryEnd;	<span class="comment">// slab内存空间的结束位置</span></span><br><span class="line">	SlabSlot   *slabFreeHead;	<span class="comment">// 链表头</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Memory used for input and output tape buffers. */</span></span><br><span class="line">	<span class="type">size_t</span>		tape_buffer_mem;</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>	   *lastReturnedTuple;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>			currentRun;</span><br><span class="line"></span><br><span class="line">	LogicalTape **inputTapes;</span><br><span class="line">	<span class="type">int</span>			nInputTapes;</span><br><span class="line">	<span class="type">int</span>			nInputRuns;</span><br><span class="line"></span><br><span class="line">	LogicalTape **outputTapes;</span><br><span class="line">	<span class="type">int</span>			nOutputTapes;</span><br><span class="line">	<span class="type">int</span>			nOutputRuns;</span><br><span class="line"></span><br><span class="line">	LogicalTape *destTape;		<span class="comment">/* current output tape */</span></span><br><span class="line"></span><br><span class="line">	LogicalTape *result_tape;	<span class="comment">/* actual tape of finished output */</span></span><br><span class="line">	<span class="type">int</span>			current;		<span class="comment">/* array index (only used if SORTEDINMEM) */</span></span><br><span class="line">	<span class="type">bool</span>		eof_reached;	<span class="comment">/* reached EOF (needed for cursors) */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* markpos_xxx holds marked position for mark and restore */</span></span><br><span class="line">	<span class="type">long</span>		markpos_block;	<span class="comment">/* tape block# (only used if SORTEDONTAPE) */</span></span><br><span class="line">	<span class="type">int</span>			markpos_offset; <span class="comment">/* saved &quot;current&quot;, or offset in tape block */</span></span><br><span class="line">	<span class="type">bool</span>		markpos_eof;	<span class="comment">/* saved &quot;eof_reached&quot; */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>			worker;</span><br><span class="line">	Sharedsort *shared;</span><br><span class="line">	<span class="type">int</span>			nParticipants;</span><br><span class="line"></span><br><span class="line">	TupleDesc	tupDesc;</span><br><span class="line">	SortSupport sortKeys;		<span class="comment">/* array of length nKeys */</span></span><br><span class="line"></span><br><span class="line">	SortSupport onlyKey;</span><br><span class="line"></span><br><span class="line">	int64		abbrevNext;		<span class="comment">/* Tuple # at which to next check</span></span><br><span class="line"><span class="comment">								 * applicability */</span></span><br><span class="line"></span><br><span class="line">	IndexInfo  *indexInfo;		<span class="comment">// 将用于依赖的索引信息</span></span><br><span class="line">	EState	   *estate;			<span class="comment">// 解析索引表达式的运行期状态</span></span><br><span class="line"></span><br><span class="line">	Relation	heapRel;		<span class="comment">// 正在建立索引的表</span></span><br><span class="line">	Relation	indexRel;		<span class="comment">// 正在创建的index</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* These are specific to the index_btree subcase: */</span></span><br><span class="line">	<span class="type">bool</span>		enforceUnique;	<span class="comment">// 如发现重复元组,则提示</span></span><br><span class="line">	<span class="type">bool</span>		uniqueNullsNotDistinct; <span class="comment">/* unique constraint null treatment */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// index_hash情况</span></span><br><span class="line">	uint32		high_mask;		<span class="comment">/* masks for sortable part of hash code */</span></span><br><span class="line">	uint32		low_mask;</span><br><span class="line">	uint32		max_buckets;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * These variables are specific to the Datum case; they are set by</span></span><br><span class="line"><span class="comment">	 * tuplesort_begin_datum and used only by the DatumTuple routines.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Oid			datumType;</span><br><span class="line">	<span class="comment">/* we need typelen in order to know how to copy the Datums. */</span></span><br><span class="line">	<span class="type">int</span>			datumTypeLen;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Resource snapshot for time of sort start.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TRACE_SORT</span></span><br><span class="line">	PGRUsage	ru_start;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="TupSortStatus"><a href="#TupSortStatus" class="headerlink" title="TupSortStatus"></a>TupSortStatus</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//装载元组,在内存限制之内</span></span><br><span class="line">    TSS_INITIAL,                </span><br><span class="line">    <span class="comment">//装载元组到有界堆中</span></span><br><span class="line">    TSS_BOUNDED,                </span><br><span class="line">    <span class="comment">//装载元组,写入到tape中</span></span><br><span class="line">    TSS_BUILDRUNS,              </span><br><span class="line">    <span class="comment">//完全在内存中完成排序</span></span><br><span class="line">    TSS_SORTEDINMEM,            </span><br><span class="line">    <span class="comment">//完成排序,最后在tape上执行排序</span></span><br><span class="line">    TSS_SORTEDONTAPE,           </span><br><span class="line">    <span class="comment">//不落地执行最后的归并</span></span><br><span class="line">    TSS_FINALMERGE              </span><br><span class="line">&#125; TupSortStatus;</span><br></pre></td></tr></table></figure>

<h2 id="TIDBitmap"><a href="#TIDBitmap" class="headerlink" title="TIDBitmap"></a>TIDBitmap</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TIDBitmap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	NodeTag		type;			<span class="comment">/* to make it a valid Node */</span></span><br><span class="line">	MemoryContext mcxt;			<span class="comment">/* memory context containing me */</span></span><br><span class="line">	TBMStatus	status;			<span class="comment">/* see codes above */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pagetable_hash</span> *<span class="title">pagetable</span>;</span>	<span class="comment">/* hash table of PagetableEntry&#x27;s */</span></span><br><span class="line">	<span class="type">int</span>			nentries;		<span class="comment">/* number of entries in pagetable */</span></span><br><span class="line">	<span class="type">int</span>			maxentries;		<span class="comment">/* limit on same to meet maxbytes */</span></span><br><span class="line">	<span class="type">int</span>			npages;			<span class="comment">/* number of exact entries in pagetable */</span></span><br><span class="line">	<span class="type">int</span>			nchunks;		<span class="comment">/* number of lossy entries in pagetable */</span></span><br><span class="line">	TBMIteratingState iterating;	<span class="comment">/* tbm_begin_iterate called? */</span></span><br><span class="line">	uint32		lossify_start;	<span class="comment">/* offset to start lossifying hashtable at */</span></span><br><span class="line">	PagetableEntry entry1;		<span class="comment">/* used when status == TBM_ONE_PAGE */</span></span><br><span class="line">	<span class="comment">/* these are valid when iterating is true: */</span></span><br><span class="line">	PagetableEntry **spages;	<span class="comment">/* sorted exact-page list, or NULL */</span></span><br><span class="line">	PagetableEntry **schunks;	<span class="comment">/* sorted lossy-chunk list, or NULL */</span></span><br><span class="line">	dsa_pointer dsapagetable;	<span class="comment">/* dsa_pointer to the element array */</span></span><br><span class="line">	dsa_pointer dsapagetableold;	<span class="comment">/* dsa_pointer to the old element array */</span></span><br><span class="line">	dsa_pointer ptpages;		<span class="comment">/* dsa_pointer to the page array */</span></span><br><span class="line">	dsa_pointer ptchunks;		<span class="comment">/* dsa_pointer to the chunk array */</span></span><br><span class="line">	dsa_area   *dsa;			<span class="comment">/* reference to per-query dsa area */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="IndexScanDescData"><a href="#IndexScanDescData" class="headerlink" title="IndexScanDescData"></a>IndexScanDescData</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IndexScanDescData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">/* scan parameters */</span></span><br><span class="line">	Relation	heapRelation;	<span class="comment">/* 堆关系的表 */</span></span><br><span class="line">	Relation	indexRelation;	<span class="comment">/* 索引关系的表 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">SnapshotData</span> *<span class="title">xs_snapshot</span>;</span>	<span class="comment">/* 可见的快照 */</span></span><br><span class="line">	<span class="type">int</span>			numberOfKeys;	<span class="comment">/* 索引限定符条件的数量 */</span></span><br><span class="line">	<span class="type">int</span>			numberOfOrderBys;	<span class="comment">/* 排序算数子的数量 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ScanKeyData</span> *<span class="title">keyData</span>;</span>	<span class="comment">/* array of index qualifier descriptors */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ScanKeyData</span> *<span class="title">orderByData</span>;</span>	<span class="comment">/* array of ordering op descriptors */</span></span><br><span class="line">	<span class="type">bool</span>		xs_want_itup;	<span class="comment">/* 是否请求索引 */</span></span><br><span class="line">	<span class="type">bool</span>		xs_temp_snap;	<span class="comment">/* 结束时是否取消快照 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 向调用索引类型发送kill信号 */</span></span><br><span class="line">	<span class="type">bool</span>		kill_prior_tuple;	<span class="comment">/* last-returned tuple is dead */</span></span><br><span class="line">	<span class="type">bool</span>		ignore_killed_tuples;	<span class="comment">/* do not return killed entries */</span></span><br><span class="line">	<span class="type">bool</span>		xactStartedInRecovery;	<span class="comment">/* prevents killing/seeing killed</span></span><br><span class="line"><span class="comment">										 * tuples */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 索引方法的私有状态 */</span></span><br><span class="line">	<span class="type">void</span>	   *opaque;			<span class="comment">/* access-method-specific info */</span></span><br><span class="line"></span><br><span class="line">	IndexTuple	xs_itup;		<span class="comment">/* index tuple returned by AM */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">TupleDescData</span> *<span class="title">xs_itupdesc</span>;</span>	<span class="comment">/* rowtype descriptor of xs_itup */</span></span><br><span class="line">	HeapTuple	xs_hitup;		<span class="comment">/* index data returned by AM, as HeapTuple */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">TupleDescData</span> *<span class="title">xs_hitupdesc</span>;</span> <span class="comment">/* rowtype descriptor of xs_hitup */</span></span><br><span class="line"></span><br><span class="line">	ItemPointerData xs_heaptid; <span class="comment">/* result */</span></span><br><span class="line">	<span class="type">bool</span>		xs_heap_continue;	<span class="comment">/* T if must keep walking, potential</span></span><br><span class="line"><span class="comment">									 * further results */</span></span><br><span class="line">	IndexFetchTableData *xs_heapfetch;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span>		xs_recheck;		<span class="comment">/* T means scan keys must be rechecked */</span></span><br><span class="line"></span><br><span class="line">	Datum	   *xs_orderbyvals;</span><br><span class="line">	<span class="type">bool</span>	   *xs_orderbynulls;</span><br><span class="line">	<span class="type">bool</span>		xs_recheckorderby;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 共享内存中并行索引的信息 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ParallelIndexScanDescData</span> *<span class="title">parallel_scan</span>;</span></span><br><span class="line">&#125;			IndexScanDescData;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="HashPageOpaqueData"><a href="#HashPageOpaqueData" class="headerlink" title="HashPageOpaqueData"></a>HashPageOpaqueData</h2><p><img src="D:\blog\images\image-20230410152517503.png" alt="image-20230410152517503" loading="lazy"></p>
<h2 id="HashMetaPageData"><a href="#HashMetaPageData" class="headerlink" title="HashMetaPageData"></a>HashMetaPageData</h2><p><img src="D:\blog\images\image-20230410152617231.png" alt="image-20230410152617231" loading="lazy"></p>
<h2 id="MemoryContext"><a href="#MemoryContext" class="headerlink" title="MemoryContext"></a>MemoryContext</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MemoryContextData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	NodeTag		type;			<span class="comment">/* identifies exact kind of context */</span></span><br><span class="line">	<span class="comment">/* these two fields are placed here to minimize alignment wastage: */</span></span><br><span class="line">	<span class="type">bool</span>		isReset;		<span class="comment">/* T = no space alloced since last reset */</span></span><br><span class="line">	<span class="type">bool</span>		allowInCritSection; <span class="comment">/* allow palloc in critical section */</span></span><br><span class="line">	Size		mem_allocated;	<span class="comment">/* track memory allocated for this context */</span></span><br><span class="line">	<span class="type">const</span> MemoryContextMethods *methods;	<span class="comment">/* 操作函数 */</span></span><br><span class="line">	MemoryContext parent;		<span class="comment">/* 父亲节点 */</span></span><br><span class="line">	MemoryContext firstchild;	<span class="comment">/* 第一个孩子节点 */</span></span><br><span class="line">	MemoryContext prevchild;	<span class="comment">/* previous child of same parent */</span></span><br><span class="line">	MemoryContext nextchild;	<span class="comment">/* 第一个兄弟节点 */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;			<span class="comment">/* context name (just for debugging) */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *ident;			<span class="comment">/* context ID if any (just for debugging) */</span></span><br><span class="line">	MemoryContextCallback *reset_cbs;	<span class="comment">/* list of reset/delete callbacks */</span></span><br><span class="line">&#125; MemoryContextData;</span><br></pre></td></tr></table></figure>

<h2 id="ScanKey"><a href="#ScanKey" class="headerlink" title="ScanKey"></a>ScanKey</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ScanKeyData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span>			sk_flags;		<span class="comment">/* flags, see below */</span></span><br><span class="line">	AttrNumber	sk_attno;		<span class="comment">/* 表或索引的列数 */</span></span><br><span class="line">	StrategyNumber sk_strategy; <span class="comment">/* operator strategy number */</span></span><br><span class="line">	Oid			sk_subtype;		<span class="comment">/* 比较的数据类型 */</span></span><br><span class="line">	Oid			sk_collation;	<span class="comment">/* collation to use, if needed */</span></span><br><span class="line">	FmgrInfo	sk_func;		<span class="comment">/* lookup info for function to call */</span></span><br><span class="line">	Datum		sk_argument;	<span class="comment">/* 用来比较的数据 */</span></span><br><span class="line">&#125; ScanKeyData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> ScanKeyData *ScanKey;</span><br></pre></td></tr></table></figure>

<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">list_length(T_List)	<span class="comment">// 返回列表长度</span></span><br><span class="line">    </span><br><span class="line">IsA(jtnode, RangeTblRef)	<span class="comment">// 类型判断</span></span><br><span class="line">    </span><br><span class="line">lfirst(lc)	<span class="comment">// 取出，相当于demo-&gt;ptr_value</span></span><br><span class="line">    </span><br><span class="line">demo == NIL	<span class="comment">// 可以用来判断是否有数据放在demo中，一般demo地址显示0x0</span></span><br><span class="line">    </span><br><span class="line">SET enable_seqscan = OFF;	<span class="comment">// 禁用顺序扫描</span></span><br></pre></td></tr></table></figure>

<h1 id="parsetree"><a href="#parsetree" class="headerlink" title="parsetree"></a>parsetree</h1><p>进行语法分析，生成语法树</p>
<p>insert插入数据时解析树的结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((A_Const*)(((List*)((((SelectStmt*)(((InsertStmt*)(((RawStmt*)(parsetree_list.elements-&gt;ptr_value))-&gt;stmt))-&gt;selectStmt))-&gt;valuesLists).elements-&gt;ptr_value)).elements[<span class="number">0</span>])).val</span><br></pre></td></tr></table></figure>

<h1 id="querytree"><a href="#querytree" class="headerlink" title="querytree"></a>querytree</h1><p><strong>语义分析和查询重写</strong></p>
<p>会进行语义分析，会访问数据库中的对像，需要持有锁。这个过程会将简单的一个select 语句拆分成多个部分，将parse tree转换成query tree。如将整个select语句转换成：from 部分，where条件部分，group by 部分，order by 部分以及having 部分等。是任何数据库都需要操作的，并且非常重要的一环。</p>
<p><strong>解析流程</strong></p>
<p>parsetree为RawStmt类型结构体</p>
<p>​	1.pg_analyze_and_rewrite_fixedparams(parsetree, query_string, NULL, 0, NULL);</p>
<p>​	2.parse_analyze_fixedparams(parsetree, query_string, paramTypes, numParams,queryEnv);</p>
<p>​	3.transformTopLevelStmt(pstate, parseTree);</p>
<p>​	4.transformOptionalSelectInto(pstate, parseTree-&gt;stmt);</p>
<p>parseTree变为InsertStmt结构体</p>
<p>​	5.transformStmt(pstate, parseTree);</p>
<p>通过switch判断parseTree的类型为T_InsertStmt</p>
<p>​	6.transformInsertStmt(pstate, (InsertStmt *) parseTree);</p>
<p>parseTree改名stmt</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">SelectStmt *selectStmt = (SelectStmt *) stmt-&gt;selectStmt;</span><br><span class="line">...</span><br><span class="line">List	   *valuesLists = selectStmt-&gt;valuesLists;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>​	7.exprList &#x3D; transformExpressionList(pstate, (List *) linitial(valuesLists), EXPR_KIND_VALUES_SINGLE, true);</p>
<p>exprlist就是valuesLists列表</p>
<p>e是A_Const结构体</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">	foreach(lc, exprlist)</span><br><span class="line">	&#123;</span><br><span class="line">		Node	   *e = (Node *) lfirst(lc);</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * Check for &quot;something.*&quot;.  Depending on the complexity of the</span><br><span class="line">		 * &quot;something&quot;, the star could appear as the last field in ColumnRef,</span><br><span class="line">		 * or as the last indirection item in A_Indirection.</span><br><span class="line">		 */</span><br><span class="line">		if (IsA(e, ColumnRef))</span><br><span class="line">		&#123;</span><br><span class="line">			ColumnRef  *cref = (ColumnRef *) e;</span><br><span class="line"></span><br><span class="line">			if (IsA(llast(cref-&gt;fields), A_Star))</span><br><span class="line">			&#123;</span><br><span class="line">				/* It is something.*, expand into multiple items */</span><br><span class="line">				result = list_concat(result,</span><br><span class="line">									 ExpandColumnRefStar(pstate, cref,</span><br><span class="line">														 false));</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (IsA(e, A_Indirection))</span><br><span class="line">		&#123;</span><br><span class="line">			A_Indirection *ind = (A_Indirection *) e;</span><br><span class="line"></span><br><span class="line">			if (IsA(llast(ind-&gt;indirection), A_Star))</span><br><span class="line">			&#123;</span><br><span class="line">				/* It is something.*, expand into multiple items */</span><br><span class="line">				result = list_concat(result,</span><br><span class="line">									 ExpandIndirectionStar(pstate, ind,</span><br><span class="line">														   false, exprKind));</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * Not &quot;something.*&quot;, so transform as a single expression.  If it&#x27;s a</span><br><span class="line">		 * SetToDefault node and we should allow that, pass it through</span><br><span class="line">		 * unmodified.  (transformExpr will throw the appropriate error if</span><br><span class="line">		 * we&#x27;re disallowing it.)</span><br><span class="line">		 */</span><br><span class="line">		if (allowDefault &amp;&amp; IsA(e, SetToDefault))</span><br><span class="line">			 /* do nothing */ ;</span><br><span class="line">		else</span><br><span class="line">			e = transformExpr(pstate, e, exprKind);</span><br><span class="line"></span><br><span class="line">		result = lappend(result, e);</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>将A_Const转变为Expr	</p>
<p>​	8.e &#x3D; transformExpr(pstate, e, exprKind);</p>
<p>e改名为expr</p>
<p>​	9.result &#x3D; transformExprRecurse(pstate, expr);</p>
<p>switch循环判断expr为T_A_Const</p>
<p>​	10.result &#x3D; (Node *) make_const(pstate, (A_Const *) expr);</p>
<p>switch循环判断节点数据类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">switch</span> (nodeTag(&amp;aconst-&gt;val))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> T_Integer:</span><br><span class="line"></span><br><span class="line">			val = Int32GetDatum(intVal(&amp;aconst-&gt;val));</span><br><span class="line"></span><br><span class="line">			typeid = INT4OID;</span><br><span class="line">			typelen = <span class="keyword">sizeof</span>(int32);</span><br><span class="line">			typebyval = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> T_Float:</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* could be an oversize integer as well as a float ... */</span></span><br><span class="line"></span><br><span class="line">				int64		val64;</span><br><span class="line">				<span class="type">char</span>	   *endptr;</span><br><span class="line"></span><br><span class="line">				errno = <span class="number">0</span>;</span><br><span class="line">				val64 = strtoi64(aconst-&gt;val.fval.fval, &amp;endptr, <span class="number">10</span>);</span><br><span class="line">				<span class="keyword">if</span> (errno == <span class="number">0</span> &amp;&amp; *endptr == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">。。。</span><br></pre></td></tr></table></figure>

<p>获取Datum类型的val，创建Const类型数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">con = makeConst(typeid,</span><br><span class="line">				<span class="number">-1</span>,			<span class="comment">/* typmod -1 is OK for all cases */</span></span><br><span class="line">				InvalidOid, <span class="comment">/* all cases are uncollatable types */</span></span><br><span class="line">				typelen,</span><br><span class="line">				val,</span><br><span class="line">				<span class="literal">false</span>,</span><br><span class="line">				typebyval);</span><br><span class="line">con-&gt;location = aconst-&gt;location;</span><br></pre></td></tr></table></figure>

<p>回到第7步方法里的switch循环体进行下一个参数</p>
<h1 id="plantree"><a href="#plantree" class="headerlink" title="plantree"></a>plantree</h1><p>根据上面的query tree产生执行计划。这部分核心代码在planner.c中，是PG的Query Optimizer。会根据表和索引的统计信息去计算不同路径的可能代价值，最后选出最优者。</p>
<p><strong>解析流程</strong></p>
<p>1.pg_plan_queries(querytree_list, query_string, CURSOR_OPT_PARALLEL_OK, NULL);</p>
<ul>
<li><p>query_list &#x3D;&#x3D; querytrees-&gt;elements</p>
</li>
<li><p>query &#x3D;&#x3D; (Query*)(query_list-&gt;ptr_value)</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">foreach(query_list, querytrees)</span><br><span class="line">	&#123;</span><br><span class="line">		Query	   *query = lfirst_node(Query, query_list);</span><br><span class="line">		PlannedStmt *stmt;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (query-&gt;commandType == CMD_UTILITY)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* Utility commands require no planning. */</span></span><br><span class="line">			stmt = makeNode(PlannedStmt);</span><br><span class="line">			stmt-&gt;commandType = CMD_UTILITY;</span><br><span class="line">			stmt-&gt;canSetTag = query-&gt;canSetTag;</span><br><span class="line">			stmt-&gt;utilityStmt = query-&gt;utilityStmt;</span><br><span class="line">			stmt-&gt;stmt_location = query-&gt;stmt_location;</span><br><span class="line">			stmt-&gt;stmt_len = query-&gt;stmt_len;</span><br><span class="line">			stmt-&gt;queryId = query-&gt;queryId;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			stmt = pg_plan_query(query, query_string, cursorOptions,</span><br><span class="line">								 boundParams);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		stmt_list = lappend(stmt_list, stmt);</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>调用pg_plan_query函数对每一个查询进行处理并返回PlannedStmt(执行计划)结构体链表</li>
</ul>
<p>2.stmt &#x3D; <strong>pg_plan_query</strong>(query, query_string, cursorOptions, boundParams);</p>
<ul>
<li><p>query名字变为querytree	</p>
</li>
<li><p>调用planner函数负责查询计划的生成</p>
</li>
</ul>
<p>3.<strong>planner</strong>(querytree, query_string, cursorOptions, boundParams);</p>
<ul>
<li><p>querytree名字变为parse</p>
</li>
<li><p>调用standard_planner函数进入标准的查询规划处理流程</p>
</li>
</ul>
<p>4.result &#x3D; <strong>standard_planner</strong>(parse, query_string, cursorOptions, boundParams);</p>
<p>5.root &#x3D; <strong>subquery_planner</strong>(glob, parse, NULL, false, tuple_fraction);</p>
<ul>
<li>查询计划的处理优化。</li>
<li>接收Query(查询树)，返回一个Plan(计划树)。</li>
</ul>
<p>对数据进行处理，如果有运算在这得出结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    	parse-&gt;targetList = (List *)preprocess_expression(root, (Node *) parse-&gt;targetList,EXPRKIND_TARGET);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>对代码进行更改，对整型结果进行+1处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foreach(te,parse-&gt;targetList)&#123;	</span><br><span class="line">	lx = ((Const*)(((TargetEntry*)(te-&gt;ptr_value))-&gt;expr));</span><br><span class="line">	<span class="keyword">if</span> (lx-&gt;consttype == <span class="number">23</span> || lx-&gt;consttype == <span class="number">20</span>)</span><br><span class="line">		(lx-&gt;constvalue)++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.grouping_planner</p>
<ul>
<li>完成<strong>查询规划</strong>的主要工作</li>
<li>将查询中的信息进行规范化并传给query_planner函数</li>
<li>提升子链接&#x2F;子查询、预处理表达式、预处理Having子句等</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230406100235521.png" alt="image-20230406100235521" loading="lazy"></p>
<p>7.query_planner</p>
<p>为一个基本查询创建路径并获得cheapest_path(代价最低执行路径)，再调用get_cheapest_fractional_path_for_pathkeys函数获得sorted_path(对排序最优的路径)</p>
<p><img src="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230406101314834.png" alt="image-20230406101314834" loading="lazy"></p>
<p>8.make_one_rel</p>
<ol>
<li><p>调用set_base_rel_sizes函数估算每个访问路径锁涉及的记录行数和属性数，然后再调用set_base_rel_pathlists函数为每个基本关系生成一个RelOptInfo结构并生成路径，该路径放在RelOptInfo结构的pathlist字段里;</p>
</li>
<li><p>调用make_rel_from_joinlist函数生成最终的路径。该函数生成一个RelOptInfo结构，它连接了上面提到的所有基本关系，并将最终路径组成的链表写入到pathlist字段里。说白了，这里就是把上面的基本关系的路径串起来，获得完整的路径。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rel = make_rel_from_joinlist(root, joinlist);</span><br></pre></td></tr></table></figure>

<p>rel内的pathlist存放计算的路径代价total_cost</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Path*)(rel-&gt;pathlist-&gt;elements[0]-&gt;ptr_value)</span><br></pre></td></tr></table></figure>

<h1 id="索引路径生成"><a href="#索引路径生成" class="headerlink" title="索引路径生成"></a>索引路径生成</h1><h2 id="create-index-paths"><a href="#create-index-paths" class="headerlink" title="create_index_paths"></a>create_index_paths</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">create_index_paths(PlannerInfo *root, RelOptInfo *rel)</span><br><span class="line">&#123;</span><br><span class="line">	List	   *indexpaths;<span class="comment">//存储索引路径的链表</span></span><br><span class="line">	List	   *bitindexpaths;<span class="comment">//位图索引路径</span></span><br><span class="line">	List	   *bitjoinpaths;<span class="comment">//位图路径</span></span><br><span class="line">	List	   *joinorclauses;<span class="comment">//链接子句</span></span><br><span class="line">	IndexClauseSet rclauseset;<span class="comment">//限制性条款</span></span><br><span class="line">	IndexClauseSet jclauseset;<span class="comment">//存放连接子句的集合</span></span><br><span class="line">	IndexClauseSet eclauseset;<span class="comment">//连接语句的等价类</span></span><br><span class="line">	ListCell   *lc;<span class="comment">//临时变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断有无索引，如果没有索引，就跳过整个过程</span></span><br><span class="line">	<span class="keyword">if</span> (rel-&gt;indexlist == NIL)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//收集位图路径，然后在最后处理</span></span><br><span class="line">	bitindexpaths = bitjoinpaths = joinorclauses = NIL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//依次检查每个索引</span></span><br><span class="line">	foreach(lc, rel-&gt;indexlist)</span><br><span class="line">	&#123;</span><br><span class="line">		IndexOptInfo *index = (IndexOptInfo *) lfirst(lc);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//在IndexClauseSets中保护有限大小的数组</span></span><br><span class="line">		Assert(index-&gt;nkeycolumns &lt;= INDEX_MAX_KEYS);</span><br><span class="line"></span><br><span class="line">		 <span class="comment">//忽略不符合查询的部分索引。</span></span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span> (index-&gt;indpred != NIL &amp;&amp; !index-&gt;predOK)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//识别可以匹配索引的限制性条款</span></span><br><span class="line">		MemSet(&amp;rclauseset, <span class="number">0</span>, <span class="keyword">sizeof</span>(rclauseset));</span><br><span class="line">		match_restriction_clauses_to_index(root, index, &amp;rclauseset);</span><br><span class="line"></span><br><span class="line">		 <span class="comment">//从限制性条款中建立索引路径，普通路径直接进入add_path()，位图路径被添加到bitindexpaths中</span></span><br><span class="line">		</span><br><span class="line">		get_index_paths(root, rel, index, &amp;rclauseset,</span><br><span class="line">						&amp;bitindexpaths);</span><br><span class="line"></span><br><span class="line">		 <span class="comment">//识别可以匹配索引的连接子句，这一步只找到未被合并到等价类中的 &quot;松散 &quot;连接子句，还要收集连接OR子句以备后用。</span></span><br><span class="line">		 </span><br><span class="line">		MemSet(&amp;jclauseset, <span class="number">0</span>, <span class="keyword">sizeof</span>(jclauseset));</span><br><span class="line">		match_join_clauses_to_index(root, rel, index,</span><br><span class="line">									&amp;jclauseset, &amp;joinorclauses);</span><br><span class="line"></span><br><span class="line">		 <span class="comment">//寻找能够生成与索引相匹配的连接语句的等价类</span></span><br><span class="line">		 </span><br><span class="line">		MemSet(&amp;eclauseset, <span class="number">0</span>, <span class="keyword">sizeof</span>(eclauseset));</span><br><span class="line">		match_eclass_clauses_to_index(root, index,</span><br><span class="line">									  &amp;eclauseset);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//如果找到任何普通的或类的连接子句，用它们建立参数化的索引路径</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (jclauseset.nonempty || eclauseset.nonempty)</span><br><span class="line">			consider_index_join_clauses(root, rel, index,</span><br><span class="line">										&amp;rclauseset,</span><br><span class="line">										&amp;jclauseset,</span><br><span class="line">										&amp;eclauseset,</span><br><span class="line">										&amp;bitjoinpaths);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//为限制列表中任何合适的or子句生成BitmapOrPaths</span></span><br><span class="line">	 <span class="comment">//调用generate_bitmap_or_paths函数为baserestrictinfo中的OR子句生成BitmapOrPath路径，并将它们加入到bitindexpaths链表中</span></span><br><span class="line">	indexpaths = generate_bitmap_or_paths(root, rel,</span><br><span class="line">										  rel-&gt;baserestrictinfo, NIL);</span><br><span class="line">	bitindexpaths = list_concat(bitindexpaths, indexpaths);</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//同样地，为任何合适的OR句子生成BitmapOrPaths。连接语句列表中的任何合适的OR语句生成BitmapOrPath。 将这些添加到bitjoinpaths</span></span><br><span class="line">	</span><br><span class="line">	indexpaths = generate_bitmap_or_paths(root, rel,</span><br><span class="line">										  joinorclauses, rel-&gt;baserestrictinfo);</span><br><span class="line">	bitjoinpaths = list_concat(bitjoinpaths, indexpaths);</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//如果找到了可用的东西，就为最有希望的限制位图索引路径组合生成一个BitmapHeapPath</span></span><br><span class="line">	<span class="keyword">if</span> (bitindexpaths != NIL)</span><br><span class="line">	&#123;</span><br><span class="line">		Path	   *bitmapqual;</span><br><span class="line">		BitmapHeapPath *bpath;</span><br><span class="line"></span><br><span class="line">		bitmapqual = choose_bitmap_and(root, rel, bitindexpaths);</span><br><span class="line">		<span class="comment">//调用create_bitmap_heap_path函数在BitmapAndPath路径上生成一个BitHeapPath路径，然后尝试将它加入到pathlist</span></span><br><span class="line">		bpath = create_bitmap_heap_path(root, rel, bitmapqual,</span><br><span class="line">										rel-&gt;lateral_relids, <span class="number">1.0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="comment">//尝试将它加入到pathlist</span></span><br><span class="line">		add_path(rel, (Path *) bpath);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建一个部分位图堆路径</span></span><br><span class="line">		<span class="keyword">if</span> (rel-&gt;consider_parallel &amp;&amp; rel-&gt;lateral_relids == <span class="literal">NULL</span>)</span><br><span class="line">			create_partial_bitmap_paths(root, rel, bitmapqual);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//为每个不同的参数化生成一个这样的路径 在可用的位图索引路径中产生一个这样的路径</span></span><br><span class="line">	<span class="keyword">if</span> (bitjoinpaths != NIL)</span><br><span class="line">	&#123;</span><br><span class="line">		List	   *path_outer;</span><br><span class="line">		List	   *all_path_outers;</span><br><span class="line">		ListCell   *lc;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// path_outer持有bitjoinpaths中每个路径的参数化（以节省重新计算的次数），而all_path_outers 持有所有不同的参数化集。</span></span><br><span class="line">		 </span><br><span class="line">		path_outer = all_path_outers = NIL;</span><br><span class="line">		foreach(lc, bitjoinpaths)<span class="comment">//遍历bitjoinpaths获取参数化的路径</span></span><br><span class="line">		&#123;</span><br><span class="line">			Path	   *path = (Path *) lfirst(lc);</span><br><span class="line">			Relids		required_outer;</span><br><span class="line"></span><br><span class="line">			required_outer = get_bitmap_tree_required_outer(path);</span><br><span class="line">			path_outer = lappend(path_outer, required_outer);</span><br><span class="line">			<span class="keyword">if</span> (!bms_equal_any(required_outer, all_path_outers))</span><br><span class="line">				all_path_outers = lappend(all_path_outers, required_outer);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//遍历all_path_outers，为每一个不同的参数化设置</span></span><br><span class="line">		foreach(lc, all_path_outers)</span><br><span class="line">		&#123;</span><br><span class="line">			Relids		max_outers = (Relids) lfirst(lc);</span><br><span class="line">			List	   *this_path_set;</span><br><span class="line">			Path	   *bitmapqual;</span><br><span class="line">			Relids		required_outer;</span><br><span class="line">			<span class="type">double</span>		loop_count;</span><br><span class="line">			BitmapHeapPath *bpath;</span><br><span class="line">			ListCell   *lcp;</span><br><span class="line">			ListCell   *lco;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//识别所有的位图连接路径</span></span><br><span class="line">			this_path_set = NIL;</span><br><span class="line">			forboth(lcp, bitjoinpaths, lco, path_outer)</span><br><span class="line">			&#123;</span><br><span class="line">				Path	   *path = (Path *) lfirst(lcp);</span><br><span class="line">				Relids		p_outers = (Relids) lfirst(lco);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (bms_is_subset(p_outers, max_outers))</span><br><span class="line">					this_path_set = lappend(this_path_set, path);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			 <span class="comment">//加入限制性位图路径，因为它们可以和任何连接路径一起使用</span></span><br><span class="line">			this_path_set = list_concat(this_path_set, bitindexpaths);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//为该参数化选择最佳的AND组合</span></span><br><span class="line">			bitmapqual = choose_bitmap_and(root, rel, this_path_set);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//下推路径</span></span><br><span class="line">			required_outer = get_bitmap_tree_required_outer(bitmapqual);</span><br><span class="line">			loop_count = get_loop_count(root, rel-&gt;relid, required_outer);</span><br><span class="line">			bpath = create_bitmap_heap_path(root, rel, bitmapqual,</span><br><span class="line">											required_outer, loop_count, <span class="number">0</span>);</span><br><span class="line">			add_path(rel, (Path *) bpath);<span class="comment">//加入路径到pathlist</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p><img src="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230407151115123.png" alt="image-20230407151115123" loading="lazy"></p>
<p>创建时会先往pg_class等系统表内通过btinsert插入索引元组，无论哪种索引都调用btinsert</p>
<h2 id="index-create"><a href="#index-create" class="headerlink" title="index_create"></a>index_create</h2><p>生成oid</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DefineIndex -&gt; index_create -&gt; GetNewRelFileNode</span><br></pre></td></tr></table></figure>

<h2 id="btbuild"><a href="#btbuild" class="headerlink" title="btbuild"></a>btbuild</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">btbuild(Relation heap, Relation index, IndexInfo *indexInfo)</span><br><span class="line">&#123;</span><br><span class="line">	IndexBuildResult *result;</span><br><span class="line">	BTBuildState buildstate;</span><br><span class="line">	<span class="type">double</span>		reltuples;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> BTREE_BUILD_STATS</span></span><br><span class="line">	<span class="keyword">if</span> (log_btree_build_stats)</span><br><span class="line">		ResetUsage();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">// 定义并初始化BTBuildState结构</span></span><br><span class="line">	buildstate.isunique = indexInfo-&gt;ii_Unique;</span><br><span class="line">	buildstate.nulls_not_distinct = indexInfo-&gt;ii_NullsNotDistinct;</span><br><span class="line">	buildstate.havedead = <span class="literal">false</span>;</span><br><span class="line">	buildstate.heap = heap;</span><br><span class="line">	buildstate.spool = <span class="literal">NULL</span>;</span><br><span class="line">	buildstate.spool2 = <span class="literal">NULL</span>;</span><br><span class="line">	buildstate.indtuples = <span class="number">0</span>;</span><br><span class="line">	buildstate.btleader = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (RelationGetNumberOfBlocks(index) != <span class="number">0</span>)</span><br><span class="line">		elog(ERROR, <span class="string">&quot;index \&quot;%s\&quot; already contains data&quot;</span>,</span><br><span class="line">			 RelationGetRelationName(index));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 扫描待建索引元组，构建排序时需要用到的sortkey，保存到spool</span></span><br><span class="line">	reltuples = _bt_spools_heapscan(heap, index, &amp;buildstate, indexInfo);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 通过以下方式完成构建:(1)完成spool文件的排序，(2)将已排序的元组插入到btree页面中，并(3)构建上层的水平。最后，可能还需要终止并行的使用。</span></span><br><span class="line">	_bt_leafbuild(buildstate.spool, buildstate.spool2);</span><br><span class="line">	_bt_spooldestroy(buildstate.spool);</span><br><span class="line">	<span class="keyword">if</span> (buildstate.spool2)</span><br><span class="line">		_bt_spooldestroy(buildstate.spool2);</span><br><span class="line">	<span class="keyword">if</span> (buildstate.btleader)</span><br><span class="line">		_bt_end_parallel(buildstate.btleader);</span><br><span class="line"></span><br><span class="line">	result = (IndexBuildResult *) palloc(<span class="keyword">sizeof</span>(IndexBuildResult));</span><br><span class="line"></span><br><span class="line">	result-&gt;heap_tuples = reltuples;</span><br><span class="line">	result-&gt;index_tuples = buildstate.indtuples;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> BTREE_BUILD_STATS</span></span><br><span class="line">	<span class="keyword">if</span> (log_btree_build_stats)</span><br><span class="line">	&#123;</span><br><span class="line">		ShowUsage(<span class="string">&quot;BTREE BUILD STATS&quot;</span>);</span><br><span class="line">		ResetUsage();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bt-spools-heapscan"><a href="#bt-spools-heapscan" class="headerlink" title="_bt_spools_heapscan"></a>_bt_spools_heapscan</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">double</span></span><br><span class="line">_bt_spools_heapscan(Relation heap, Relation index, BTBuildState *buildstate,</span><br><span class="line">					IndexInfo *indexInfo)</span><br><span class="line">&#123;</span><br><span class="line">	BTSpool    *btspool = (BTSpool *) palloc0(<span class="keyword">sizeof</span>(BTSpool));</span><br><span class="line">	SortCoordinate coordinate = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">double</span>		reltuples = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	btspool-&gt;heap = heap;</span><br><span class="line">	btspool-&gt;index = index;</span><br><span class="line">	btspool-&gt;isunique = indexInfo-&gt;ii_Unique;</span><br><span class="line">	btspool-&gt;nulls_not_distinct = indexInfo-&gt;ii_NullsNotDistinct;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Save as primary spool */</span></span><br><span class="line">	buildstate-&gt;spool = btspool;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Report table scan phase started */</span></span><br><span class="line">	pgstat_progress_update_param(PROGRESS_CREATEIDX_SUBPHASE,</span><br><span class="line">								 PROGRESS_BTREE_PHASE_INDEXBUILD_TABLESCAN);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Attempt to launch parallel worker scan when required */</span></span><br><span class="line">	<span class="keyword">if</span> (indexInfo-&gt;ii_ParallelWorkers &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="comment">// 启动并行加载</span></span><br><span class="line">		_bt_begin_parallel(buildstate, indexInfo-&gt;ii_Concurrent,</span><br><span class="line">						   indexInfo-&gt;ii_ParallelWorkers);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (buildstate-&gt;btleader)</span><br><span class="line">	&#123;</span><br><span class="line">		coordinate = (SortCoordinate) palloc0(<span class="keyword">sizeof</span>(SortCoordinateData));</span><br><span class="line">		coordinate-&gt;isWorker = <span class="literal">false</span>;</span><br><span class="line">		coordinate-&gt;nParticipants =</span><br><span class="line">			buildstate-&gt;btleader-&gt;nparticipanttuplesorts;</span><br><span class="line">		coordinate-&gt;sharedsort = buildstate-&gt;btleader-&gt;sharedsort;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	buildstate-&gt;spool-&gt;sortstate =</span><br><span class="line">		tuplesort_begin_index_btree(heap, index, buildstate-&gt;isunique,</span><br><span class="line">									buildstate-&gt;nulls_not_distinct,</span><br><span class="line">									maintenance_work_mem, coordinate,</span><br><span class="line">									TUPLESORT_NONE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (indexInfo-&gt;ii_Unique)</span><br><span class="line">	&#123;</span><br><span class="line">		BTSpool    *btspool2 = (BTSpool *) palloc0(<span class="keyword">sizeof</span>(BTSpool));</span><br><span class="line">		SortCoordinate coordinate2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Initialize secondary spool */</span></span><br><span class="line">		btspool2-&gt;heap = heap;</span><br><span class="line">		btspool2-&gt;index = index;</span><br><span class="line">		btspool2-&gt;isunique = <span class="literal">false</span>;</span><br><span class="line">		<span class="comment">/* Save as secondary spool */</span></span><br><span class="line">		buildstate-&gt;spool2 = btspool2;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (buildstate-&gt;btleader)</span><br><span class="line">		&#123;</span><br><span class="line">			coordinate2 = (SortCoordinate) palloc0(<span class="keyword">sizeof</span>(SortCoordinateData));</span><br><span class="line">			coordinate2-&gt;isWorker = <span class="literal">false</span>;</span><br><span class="line">			coordinate2-&gt;nParticipants =</span><br><span class="line">				buildstate-&gt;btleader-&gt;nparticipanttuplesorts;</span><br><span class="line">			coordinate2-&gt;sharedsort = buildstate-&gt;btleader-&gt;sharedsort2;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		buildstate-&gt;spool2-&gt;sortstate =</span><br><span class="line">			tuplesort_begin_index_btree(heap, index, <span class="literal">false</span>, <span class="literal">false</span>, work_mem,</span><br><span class="line">										coordinate2, TUPLESORT_NONE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 进行堆扫描填充到spool</span></span><br><span class="line">	<span class="keyword">if</span> (!buildstate-&gt;btleader)</span><br><span class="line">		reltuples = table_index_build_scan(heap, index, indexInfo, <span class="literal">true</span>, <span class="literal">true</span>,</span><br><span class="line">										   _bt_build_callback, (<span class="type">void</span> *) buildstate,</span><br><span class="line">										   <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		reltuples = _bt_parallel_heapscan(buildstate,</span><br><span class="line">										  &amp;indexInfo-&gt;ii_BrokenHotChain);</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> <span class="type">int</span>	progress_index[] = &#123;</span><br><span class="line">			PROGRESS_CREATEIDX_TUPLES_TOTAL,</span><br><span class="line">			PROGRESS_SCAN_BLOCKS_TOTAL,</span><br><span class="line">			PROGRESS_SCAN_BLOCKS_DONE</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="type">const</span> int64 progress_vals[] = &#123;</span><br><span class="line">			buildstate-&gt;indtuples,</span><br><span class="line">			<span class="number">0</span>, <span class="number">0</span></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		pgstat_progress_update_multi_param(<span class="number">3</span>, progress_index, progress_vals);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* okay, all heap tuples are spooled */</span></span><br><span class="line">	<span class="keyword">if</span> (buildstate-&gt;spool2 &amp;&amp; !buildstate-&gt;havedead)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* spool2 turns out to be unnecessary */</span></span><br><span class="line">		_bt_spooldestroy(buildstate-&gt;spool2);</span><br><span class="line">		buildstate-&gt;spool2 = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> reltuples;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bt-leafbuild"><a href="#bt-leafbuild" class="headerlink" title="_bt_leafbuild"></a>_bt_leafbuild</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_bt_leafbuild(BTSpool *btspool, BTSpool *btspool2)</span><br><span class="line">&#123;</span><br><span class="line">	BTWriteState wstate;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> BTREE_BUILD_STATS</span></span><br><span class="line">	<span class="keyword">if</span> (log_btree_build_stats)</span><br><span class="line">	&#123;</span><br><span class="line">		ShowUsage(<span class="string">&quot;BTREE BUILD (Spool) STATISTICS&quot;</span>);</span><br><span class="line">		ResetUsage();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>							<span class="comment">/* BTREE_BUILD_STATS */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Execute the sort */</span></span><br><span class="line">	pgstat_progress_update_param(PROGRESS_CREATEIDX_SUBPHASE,</span><br><span class="line">								 PROGRESS_BTREE_PHASE_PERFORMSORT_1);</span><br><span class="line">    <span class="comment">// 对spool内的索引元组进行排序，这时候btspool-&gt;sortstate-&gt;memtuples内的数组变成有序数组</span></span><br><span class="line">	tuplesort_performsort(btspool-&gt;sortstate);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (btspool2)</span><br><span class="line">	&#123;</span><br><span class="line">		pgstat_progress_update_param(PROGRESS_CREATEIDX_SUBPHASE,</span><br><span class="line">									 PROGRESS_BTREE_PHASE_PERFORMSORT_2);</span><br><span class="line">		tuplesort_performsort(btspool2-&gt;sortstate);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wstate.heap = btspool-&gt;heap;</span><br><span class="line">	wstate.index = btspool-&gt;index;</span><br><span class="line">	wstate.inskey = _bt_mkscankey(wstate.index, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">/* _bt_mkscankey() won&#x27;t set allequalimage without metapage */</span></span><br><span class="line">	wstate.inskey-&gt;allequalimage = _bt_allequalimage(wstate.index, <span class="literal">true</span>);</span><br><span class="line">	wstate.btws_use_wal = RelationNeedsWAL(wstate.index);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* reserve the metapage */</span></span><br><span class="line">	wstate.btws_pages_alloced = BTREE_METAPAGE + <span class="number">1</span>;</span><br><span class="line">	wstate.btws_pages_written = <span class="number">0</span>;</span><br><span class="line">	wstate.btws_zeropage = <span class="literal">NULL</span>;	<span class="comment">/* until needed */</span></span><br><span class="line"></span><br><span class="line">	pgstat_progress_update_param(PROGRESS_CREATEIDX_SUBPHASE,</span><br><span class="line">								 PROGRESS_BTREE_PHASE_LEAF_LOAD);</span><br><span class="line">    <span class="comment">// 读取元组构建叶子</span></span><br><span class="line">	_bt_load(&amp;wstate, btspool, btspool2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="bt-load"><a href="#bt-load" class="headerlink" title="_bt_load"></a>_bt_load</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_bt_load(BTWriteState *wstate, BTSpool *btspool, BTSpool *btspool2)</span><br><span class="line">&#123;</span><br><span class="line">	BTPageState *state = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">bool</span>		merge = (btspool2 != <span class="literal">NULL</span>);</span><br><span class="line">	IndexTuple	itup,</span><br><span class="line">				itup2 = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">bool</span>		load1;</span><br><span class="line">	TupleDesc	tupdes = RelationGetDescr(wstate-&gt;index);</span><br><span class="line">	<span class="type">int</span>			i,</span><br><span class="line">				keysz = IndexRelationGetNumberOfKeyAttributes(wstate-&gt;index);</span><br><span class="line">	SortSupport sortKeys;</span><br><span class="line">	int64		tuples_done = <span class="number">0</span>;</span><br><span class="line">	<span class="type">bool</span>		deduplicate;</span><br><span class="line"></span><br><span class="line">	deduplicate = wstate-&gt;inskey-&gt;allequalimage &amp;&amp; !btspool-&gt;isunique &amp;&amp;</span><br><span class="line">		BTGetDeduplicateItems(wstate-&gt;index);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (merge)</span><br><span class="line">	&#123;	</span><br><span class="line">        <span class="comment">// 检查是否有spool2需要与spool合并</span></span><br><span class="line">        ...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (deduplicate)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 有重复数据和进行压缩</span></span><br><span class="line">        ...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* merging and deduplication are both unnecessary */</span></span><br><span class="line">		<span class="keyword">while</span> ((itup = tuplesort_getindextuple(btspool-&gt;sortstate,</span><br><span class="line">											   <span class="literal">true</span>)) != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 当我们发现第一个元组时, 创建第一个索引页 */</span></span><br><span class="line">			<span class="keyword">if</span> (state == <span class="literal">NULL</span>)</span><br><span class="line">				state = _bt_pagestate(wstate, <span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">			<span class="comment">// 将指定的索引元组插入到索引页结构中，在索引页结构空间不足时，会申请一个页面作为它的右兄弟，继续插入操作，最后会更新兄弟或者父子关系。</span></span><br><span class="line">			_bt_buildadd(wstate, state, itup, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Report progress */</span></span><br><span class="line">			pgstat_progress_update_param(PROGRESS_CREATEIDX_TUPLES_DONE,</span><br><span class="line">										 ++tuples_done);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 关闭最后的页面并写入metapage，将完成的btree进行持久化，在此过程会更新父子页的链接关系 */</span></span><br><span class="line">	_bt_uppershutdown(wstate, state);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (wstate-&gt;btws_use_wal)</span><br><span class="line">		smgrimmedsync(RelationGetSmgr(wstate-&gt;index), MAIN_FORKNUM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="bt-uppershutdown"><a href="#bt-uppershutdown" class="headerlink" title="_bt_uppershutdown"></a>_bt_uppershutdown</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">_bt_uppershutdown(BTWriteState *wstate, BTPageState *state)</span><br><span class="line">&#123;</span><br><span class="line">	BTPageState *s;</span><br><span class="line">	BlockNumber rootblkno = P_NONE;</span><br><span class="line">	uint32		rootlevel = <span class="number">0</span>;</span><br><span class="line">	Page		metapage;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Each iteration of this loop completes one more level of the tree.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (s = state; s != <span class="literal">NULL</span>; s = s-&gt;btps_next)</span><br><span class="line">	&#123;</span><br><span class="line">		BlockNumber blkno;</span><br><span class="line">		BTPageOpaque opaque;</span><br><span class="line"></span><br><span class="line">		blkno = s-&gt;btps_blkno;</span><br><span class="line">		opaque = BTPageGetOpaque(s-&gt;btps_page);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We have to link the last page on this level to somewhere.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * If we&#x27;re at the top, it&#x27;s the root, so attach it to the metapage.</span></span><br><span class="line"><span class="comment">		 * Otherwise, add an entry for it to its parent using its low key.</span></span><br><span class="line"><span class="comment">		 * This may cause the last page of the parent level to split, but</span></span><br><span class="line"><span class="comment">		 * that&#x27;s not a problem -- we haven&#x27;t gotten to it yet.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (s-&gt;btps_next == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			opaque-&gt;btpo_flags |= BTP_ROOT;</span><br><span class="line">			rootblkno = blkno;</span><br><span class="line">			rootlevel = s-&gt;btps_level;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			Assert((BTreeTupleGetNAtts(s-&gt;btps_lowkey, wstate-&gt;index) &lt;=</span><br><span class="line">					IndexRelationGetNumberOfKeyAttributes(wstate-&gt;index) &amp;&amp;</span><br><span class="line">					BTreeTupleGetNAtts(s-&gt;btps_lowkey, wstate-&gt;index) &gt; <span class="number">0</span>) ||</span><br><span class="line">				   P_LEFTMOST(opaque));</span><br><span class="line">			Assert(BTreeTupleGetNAtts(s-&gt;btps_lowkey, wstate-&gt;index) == <span class="number">0</span> ||</span><br><span class="line">				   !P_LEFTMOST(opaque));</span><br><span class="line">			BTreeTupleSetDownLink(s-&gt;btps_lowkey, blkno);</span><br><span class="line">			_bt_buildadd(wstate, s-&gt;btps_next, s-&gt;btps_lowkey, <span class="number">0</span>);</span><br><span class="line">			pfree(s-&gt;btps_lowkey);</span><br><span class="line">			s-&gt;btps_lowkey = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * This is the rightmost page, so the ItemId array needs to be slid</span></span><br><span class="line"><span class="comment">		 * back one slot.  Then we can dump out the page.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		_bt_slideleft(s-&gt;btps_page);</span><br><span class="line">		_bt_blwritepage(wstate, s-&gt;btps_page, s-&gt;btps_blkno);</span><br><span class="line">		s-&gt;btps_page = <span class="literal">NULL</span>;	<span class="comment">/* writepage freed the workspace */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * As the last step in the process, construct the metapage and make it</span></span><br><span class="line"><span class="comment">	 * point to the new root (unless we had no data at all, in which case it&#x27;s</span></span><br><span class="line"><span class="comment">	 * set to point to &quot;P_NONE&quot;).  This changes the index to the &quot;valid&quot; state</span></span><br><span class="line"><span class="comment">	 * by filling in a valid magic number in the metapage.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	metapage = (Page) palloc(BLCKSZ);</span><br><span class="line">	_bt_initmetapage(metapage, rootblkno, rootlevel,</span><br><span class="line">					 wstate-&gt;inskey-&gt;allequalimage);</span><br><span class="line">	_bt_blwritepage(wstate, metapage, BTREE_METAPAGE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="l-bt-blwritepage"><a href="#l-bt-blwritepage" class="headerlink" title="l_bt_blwritepage"></a>l_bt_blwritepage</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">l_bt_blwritepage</span><span class="params">(BTWriteState *wstate, Page page, BlockNumber blkno)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* XLOG stuff */</span></span><br><span class="line">	<span class="keyword">if</span> (wstate-&gt;btws_use_wal)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* We use the XLOG_FPI record type for this */</span></span><br><span class="line">		log_newpage(&amp;wstate-&gt;index-&gt;rd_node, MAIN_FORKNUM, blkno, page, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we have to write pages nonsequentially, fill in the space with</span></span><br><span class="line"><span class="comment">	 * zeroes until we come back and overwrite.  This is not logically</span></span><br><span class="line"><span class="comment">	 * necessary on standard Unix filesystems (unwritten space will read as</span></span><br><span class="line"><span class="comment">	 * zeroes anyway), but it should help to avoid fragmentation. The dummy</span></span><br><span class="line"><span class="comment">	 * pages aren&#x27;t WAL-logged though.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">while</span> (blkno &gt; wstate-&gt;btws_pages_written)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!wstate-&gt;btws_zeropage)</span><br><span class="line">			wstate-&gt;btws_zeropage = (Page) palloc0(BLCKSZ);</span><br><span class="line">		<span class="comment">/* don&#x27;t set checksum for all-zero page */</span></span><br><span class="line">		smgrextend(RelationGetSmgr(wstate-&gt;index), MAIN_FORKNUM,</span><br><span class="line">				   wstate-&gt;btws_pages_written++,</span><br><span class="line">				   (<span class="type">char</span> *) wstate-&gt;btws_zeropage,</span><br><span class="line">				   <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PageSetChecksumInplace(page, blkno);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Now write the page.  There&#x27;s no need for smgr to schedule an fsync for</span></span><br><span class="line"><span class="comment">	 * this write; we&#x27;ll do it ourselves before ending the build.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (blkno == wstate-&gt;btws_pages_written)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* extending the file... */</span></span><br><span class="line">		smgrextend(RelationGetSmgr(wstate-&gt;index), MAIN_FORKNUM, blkno,</span><br><span class="line">				   (<span class="type">char</span> *) page, <span class="literal">true</span>);</span><br><span class="line">		wstate-&gt;btws_pages_written++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* overwriting a block we zero-filled before */</span></span><br><span class="line">		smgrwrite(RelationGetSmgr(wstate-&gt;index), MAIN_FORKNUM, blkno,</span><br><span class="line">				  (<span class="type">char</span> *) page, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pfree(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="btinsert"><a href="#btinsert" class="headerlink" title="btinsert"></a>btinsert</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="title function_">btinsert</span><span class="params">(Relation rel, Datum *values, <span class="type">bool</span> *isnull,</span></span><br><span class="line"><span class="params">		 ItemPointer ht_ctid, Relation heapRel,</span></span><br><span class="line"><span class="params">		 IndexUniqueCheck checkUnique,</span></span><br><span class="line"><span class="params">		 <span class="type">bool</span> indexUnchanged,</span></span><br><span class="line"><span class="params">		 IndexInfo *indexInfo)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span>		result;</span><br><span class="line">	IndexTuple	itup;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 构建一个索引元组 */</span></span><br><span class="line">	itup = index_form_tuple(RelationGetDescr(rel), values, isnull);</span><br><span class="line">	itup-&gt;t_tid = *ht_ctid;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 进行插入</span></span><br><span class="line">	result = _bt_doinsert(rel, itup, checkUnique, indexUnchanged, heapRel);</span><br><span class="line"></span><br><span class="line">	pfree(itup);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bt-doinsert"><a href="#bt-doinsert" class="headerlink" title="_bt_doinsert"></a>_bt_doinsert</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line">_bt_doinsert(Relation rel, IndexTuple itup,</span><br><span class="line">			 IndexUniqueCheck checkUnique, <span class="type">bool</span> indexUnchanged,</span><br><span class="line">			 Relation heapRel)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span>		is_unique = <span class="literal">false</span>;</span><br><span class="line">	BTInsertStateData insertstate;</span><br><span class="line">	BTScanInsert itup_key;</span><br><span class="line">	BTStack		<span class="built_in">stack</span>;</span><br><span class="line">	<span class="type">bool</span>		checkingunique = (checkUnique != UNIQUE_CHECK_NO);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 计算元组的扫描键值scan key */</span></span><br><span class="line">	itup_key = _bt_mkscankey(rel, itup);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (checkingunique)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!itup_key-&gt;anynullkeys)</span><br><span class="line">		&#123;</span><br><span class="line">			itup_key-&gt;scantid = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			checkingunique = <span class="literal">false</span>;</span><br><span class="line">			Assert(checkUnique != UNIQUE_CHECK_EXISTING);</span><br><span class="line">			is_unique = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	insertstate.itup = itup;</span><br><span class="line">	insertstate.itemsz = MAXALIGN(IndexTupleSize(itup));</span><br><span class="line">	insertstate.itup_key = itup_key;</span><br><span class="line">	insertstate.bounds_valid = <span class="literal">false</span>;</span><br><span class="line">	insertstate.buf = InvalidBuffer;</span><br><span class="line">	insertstate.postingoff = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">search:</span><br><span class="line">	<span class="comment">// 查找应该包含索引元组的页面</span></span><br><span class="line">	<span class="built_in">stack</span> = _bt_search_insert(rel, &amp;insertstate);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (checkingunique)</span><br><span class="line">	&#123;</span><br><span class="line">		TransactionId xwait;</span><br><span class="line">		uint32		speculativeToken;</span><br><span class="line"></span><br><span class="line">		xwait = _bt_check_unique(rel, &amp;insertstate, heapRel, checkUnique,</span><br><span class="line">								 &amp;is_unique, &amp;speculativeToken);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(TransactionIdIsValid(xwait)))</span><br><span class="line">		&#123;</span><br><span class="line">			_bt_relbuf(rel, insertstate.buf);</span><br><span class="line">			insertstate.buf = InvalidBuffer;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (speculativeToken)</span><br><span class="line">				SpeculativeInsertionWait(xwait, speculativeToken);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				XactLockTableWait(xwait, rel, &amp;itup-&gt;t_tid, XLTW_InsertIndex);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">stack</span>)</span><br><span class="line">				_bt_freestack(<span class="built_in">stack</span>);</span><br><span class="line">			<span class="keyword">goto</span> search;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (itup_key-&gt;heapkeyspace)</span><br><span class="line">			itup_key-&gt;scantid = &amp;itup-&gt;t_tid;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (checkUnique != UNIQUE_CHECK_EXISTING)</span><br><span class="line">	&#123;</span><br><span class="line">		OffsetNumber newitemoff;</span><br><span class="line"></span><br><span class="line">		CheckForSerializableConflictIn(rel, <span class="literal">NULL</span>, BufferGetBlockNumber(insertstate.buf));</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 在当前页面查找索引元组合适的插入位置</span></span><br><span class="line">		newitemoff = _bt_findinsertloc(rel, &amp;insertstate, checkingunique,</span><br><span class="line">									   indexUnchanged, <span class="built_in">stack</span>, heapRel);</span><br><span class="line">        <span class="comment">// 进行插入</span></span><br><span class="line">		_bt_insertonpg(rel, itup_key, insertstate.buf, InvalidBuffer, <span class="built_in">stack</span>,</span><br><span class="line">					   itup, insertstate.itemsz, newitemoff,</span><br><span class="line">					   insertstate.postingoff, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		_bt_relbuf(rel, insertstate.buf);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">stack</span>)</span><br><span class="line">		_bt_freestack(<span class="built_in">stack</span>);</span><br><span class="line">	pfree(itup_key);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> is_unique;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="btbeginscan"><a href="#btbeginscan" class="headerlink" title="btbeginscan"></a>btbeginscan</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">IndexScanDesc</span><br><span class="line"><span class="title function_">btbeginscan</span><span class="params">(Relation rel, <span class="type">int</span> nkeys, <span class="type">int</span> norderbys)</span></span><br><span class="line">&#123;</span><br><span class="line">	IndexScanDesc scan;</span><br><span class="line">	BTScanOpaque so;</span><br><span class="line">	Assert(norderbys == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 得到扫描*/</span></span><br><span class="line">	scan = RelationGetIndexScan(rel, nkeys, norderbys);</span><br><span class="line">	</span><br><span class="line">	so = (BTScanOpaque) palloc(<span class="keyword">sizeof</span>(BTScanOpaqueData));</span><br><span class="line">	BTScanPosInvalidate(so-&gt;currPos);</span><br><span class="line">	BTScanPosInvalidate(so-&gt;markPos);</span><br><span class="line">	<span class="keyword">if</span> (scan-&gt;numberOfKeys &gt; <span class="number">0</span>)</span><br><span class="line">		so-&gt;keyData = (ScanKey) palloc(scan-&gt;numberOfKeys * <span class="keyword">sizeof</span>(ScanKeyData));</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		so-&gt;keyData = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// 扫描信息生成并赋值</span></span><br><span class="line">	so-&gt;arrayKeyData = <span class="literal">NULL</span>;	<span class="comment">/* assume no array keys for now */</span></span><br><span class="line">	so-&gt;numArrayKeys = <span class="number">0</span>;</span><br><span class="line">	so-&gt;arrayKeys = <span class="literal">NULL</span>;</span><br><span class="line">	so-&gt;arrayContext = <span class="literal">NULL</span>;</span><br><span class="line">	so-&gt;killedItems = <span class="literal">NULL</span>;		<span class="comment">/* until needed */</span></span><br><span class="line">	so-&gt;numKilled = <span class="number">0</span>;</span><br><span class="line">	so-&gt;currTuples = so-&gt;markTuples = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	scan-&gt;xs_itupdesc = RelationGetDescr(rel);</span><br><span class="line"></span><br><span class="line">	scan-&gt;opaque = so;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> scan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="btrescan"><a href="#btrescan" class="headerlink" title="btrescan"></a>btrescan</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">btrescan</span><span class="params">(IndexScanDesc scan, ScanKey scankey, <span class="type">int</span> nscankeys,</span></span><br><span class="line"><span class="params">		 ScanKey orderbys, <span class="type">int</span> norderbys)</span></span><br><span class="line">&#123;</span><br><span class="line">	BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we aren&#x27;t holding any read locks, but gotta drop the pins */</span></span><br><span class="line">	<span class="keyword">if</span> (BTScanPosIsValid(so-&gt;currPos))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* Before leaving current page, deal with any killed items */</span></span><br><span class="line">		<span class="keyword">if</span> (so-&gt;numKilled &gt; <span class="number">0</span>)</span><br><span class="line">			_bt_killitems(scan);</span><br><span class="line">		BTScanPosUnpinIfPinned(so-&gt;currPos);</span><br><span class="line">		BTScanPosInvalidate(so-&gt;currPos);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	so-&gt;markItemIndex = <span class="number">-1</span>;</span><br><span class="line">	so-&gt;arrayKeyCount = <span class="number">0</span>;</span><br><span class="line">	BTScanPosUnpinIfPinned(so-&gt;markPos);</span><br><span class="line">	BTScanPosInvalidate(so-&gt;markPos);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (scankey &amp;&amp; scan-&gt;numberOfKeys &gt; <span class="number">0</span>)</span><br><span class="line">		memmove(scan-&gt;keyData,</span><br><span class="line">				scankey,</span><br><span class="line">				scan-&gt;numberOfKeys * <span class="keyword">sizeof</span>(ScanKeyData));</span><br><span class="line">	so-&gt;numberOfKeys = <span class="number">0</span>;		<span class="comment">/* until _bt_preprocess_keys sets it */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If any keys are SK_SEARCHARRAY type, set up array-key info */</span></span><br><span class="line">	_bt_preprocess_array_keys(scan);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="btgettuple"><a href="#btgettuple" class="headerlink" title="btgettuple"></a>btgettuple</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="title function_">btgettuple</span><span class="params">(IndexScanDesc scan, ScanDirection dir)</span></span><br><span class="line">&#123;</span><br><span class="line">	BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;</span><br><span class="line">	<span class="type">bool</span>		res;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	scan-&gt;xs_recheck = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (so-&gt;numArrayKeys &amp;&amp; !BTScanPosIsValid(so-&gt;currPos))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* punt if we have any unsatisfiable array keys */</span></span><br><span class="line">		<span class="keyword">if</span> (so-&gt;numArrayKeys &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		_bt_start_array_keys(scan, dir);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This loop handles advancing to the next array elements, if any */</span></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 如果没有初始化，调用_bt_first重新扫描</span></span><br><span class="line">		<span class="keyword">if</span> (!BTScanPosIsValid(so-&gt;currPos))</span><br><span class="line">            <span class="comment">// 进行定位，获取第一个符合索引条件的位置</span></span><br><span class="line">			res = _bt_first(scan, dir);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (scan-&gt;kill_prior_tuple)</span><br><span class="line">			&#123;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span> (so-&gt;killedItems == <span class="literal">NULL</span>)</span><br><span class="line">					so-&gt;killedItems = (<span class="type">int</span> *)</span><br><span class="line">						palloc(MaxIndexTuplesPerPage * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">				<span class="keyword">if</span> (so-&gt;numKilled &lt; MaxIndexTuplesPerPage)</span><br><span class="line">					so-&gt;killedItems[so-&gt;numKilled++] = so-&gt;currPos.itemIndex;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 调用_bt_next函数得到下一个元组</span></span><br><span class="line">			res = _bt_next(scan, dir);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* If we have a tuple, return it ... */</span></span><br><span class="line">		<span class="keyword">if</span> (res)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">/* ... otherwise see if we have more array keys to deal with */</span></span><br><span class="line">	&#125; <span class="keyword">while</span> (so-&gt;numArrayKeys &amp;&amp; _bt_advance_array_keys(scan, dir));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hashbuild"><a href="#hashbuild" class="headerlink" title="hashbuild"></a>hashbuild</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">IndexBuildResult *</span><br><span class="line"><span class="title function_">hashbuild</span><span class="params">(Relation heap, Relation index, IndexInfo *indexInfo)</span></span><br><span class="line">&#123;</span><br><span class="line">	IndexBuildResult *result;</span><br><span class="line">	BlockNumber relpages;</span><br><span class="line">	<span class="type">double</span>		reltuples;</span><br><span class="line">	<span class="type">double</span>		allvisfrac;</span><br><span class="line">	uint32		num_buckets;</span><br><span class="line">	<span class="type">long</span>		sort_threshold;</span><br><span class="line">	HashBuildState buildstate;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (RelationGetNumberOfBlocks(index) != <span class="number">0</span>)</span><br><span class="line">		elog(ERROR, <span class="string">&quot;index \&quot;%s\&quot; already contains data&quot;</span>,</span><br><span class="line">			 RelationGetRelationName(index));</span><br><span class="line"></span><br><span class="line">	estimate_rel_size(heap, <span class="literal">NULL</span>, &amp;relpages, &amp;reltuples, &amp;allvisfrac);</span><br><span class="line">    </span><br><span class="line">    *******************************************************************</span><br><span class="line">	<span class="comment">// 初始化元页面、桶、位图页</span></span><br><span class="line">	num_buckets = _hash_init(index, reltuples, MAIN_FORKNUM);</span><br><span class="line">    *******************************************************************</span><br><span class="line">    </span><br><span class="line">	sort_threshold = (maintenance_work_mem * <span class="number">1024L</span>) / BLCKSZ;</span><br><span class="line">	<span class="keyword">if</span> (index-&gt;rd_rel-&gt;relpersistence != RELPERSISTENCE_TEMP)</span><br><span class="line">		sort_threshold = Min(sort_threshold, NBuffers);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		sort_threshold = Min(sort_threshold, NLocBuffer);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (num_buckets &gt;= (uint32) sort_threshold)</span><br><span class="line">		buildstate.spool = _h_spoolinit(heap, index, num_buckets);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		buildstate.spool = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* prepare to build the index */</span></span><br><span class="line">	buildstate.indtuples = <span class="number">0</span>;</span><br><span class="line">	buildstate.heapRel = heap;</span><br><span class="line">	</span><br><span class="line">    *******************************************************************</span><br><span class="line">	<span class="comment">// 扫描堆元组构成索引元组插入页面</span></span><br><span class="line">	reltuples = table_index_build_scan(heap, index, indexInfo, <span class="literal">true</span>, <span class="literal">true</span>,</span><br><span class="line">									   hashbuildCallback,</span><br><span class="line">									   (<span class="type">void</span> *) &amp;buildstate, <span class="literal">NULL</span>);</span><br><span class="line">    *******************************************************************</span><br><span class="line">	pgstat_progress_update_param(PROGRESS_CREATEIDX_TUPLES_TOTAL,</span><br><span class="line">								 buildstate.indtuples);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (buildstate.spool)</span><br><span class="line">	&#123;</span><br><span class="line">		_h_indexbuild(buildstate.spool, buildstate.heapRel);</span><br><span class="line">		_h_spooldestroy(buildstate.spool);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result = (IndexBuildResult *) palloc(<span class="keyword">sizeof</span>(IndexBuildResult));</span><br><span class="line"></span><br><span class="line">	result-&gt;heap_tuples = reltuples;</span><br><span class="line">	result-&gt;index_tuples = buildstate.indtuples;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hashbuildCallback"><a href="#hashbuildCallback" class="headerlink" title="hashbuildCallback"></a>hashbuildCallback</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">hashbuildCallback</span><span class="params">(Relation index,</span></span><br><span class="line"><span class="params">				  ItemPointer tid,</span></span><br><span class="line"><span class="params">				  Datum *values,</span></span><br><span class="line"><span class="params">				  <span class="type">bool</span> *isnull,</span></span><br><span class="line"><span class="params">				  <span class="type">bool</span> tupleIsAlive,</span></span><br><span class="line"><span class="params">				  <span class="type">void</span> *state)</span></span><br><span class="line">&#123;</span><br><span class="line">	HashBuildState *buildstate = (HashBuildState *) state;</span><br><span class="line">	Datum		index_values[<span class="number">1</span>];</span><br><span class="line">	<span class="type">bool</span>		index_isnull[<span class="number">1</span>];</span><br><span class="line">	IndexTuple	itup;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* convert data to a hash key; on failure, do not insert anything */</span></span><br><span class="line">	<span class="keyword">if</span> (!_hash_convert_tuple(index,</span><br><span class="line">							 values, isnull,</span><br><span class="line">							 index_values, index_isnull))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Either spool the tuple for sorting, or just put it into the index */</span></span><br><span class="line">	<span class="keyword">if</span> (buildstate-&gt;spool)</span><br><span class="line">		_h_spool(buildstate-&gt;spool, tid, index_values, index_isnull);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* form an index tuple and point it at the heap tuple */</span></span><br><span class="line">		itup = index_form_tuple(RelationGetDescr(index),</span><br><span class="line">								index_values, index_isnull);</span><br><span class="line">		itup-&gt;t_tid = *tid;</span><br><span class="line">    *******************************************************************</span><br><span class="line">        <span class="comment">// 将索引元组插入到页面</span></span><br><span class="line">		_hash_doinsert(index, itup, buildstate-&gt;heapRel);</span><br><span class="line">    *******************************************************************</span><br><span class="line">		pfree(itup);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	buildstate-&gt;indtuples += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="hash-doinsert"><a href="#hash-doinsert" class="headerlink" title="_hash_doinsert"></a>_hash_doinsert</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_hash_doinsert(Relation rel, IndexTuple itup, Relation heapRel)</span><br><span class="line">&#123;</span><br><span class="line">	Buffer		buf = InvalidBuffer;</span><br><span class="line">	Buffer		bucket_buf;</span><br><span class="line">	Buffer		metabuf;</span><br><span class="line">	HashMetaPage metap;</span><br><span class="line">	HashMetaPage usedmetap = <span class="literal">NULL</span>;</span><br><span class="line">	Page		metapage;</span><br><span class="line">	Page		page;</span><br><span class="line">	HashPageOpaque pageopaque;</span><br><span class="line">	Size		itemsz;</span><br><span class="line">	<span class="type">bool</span>		do_expand;</span><br><span class="line">	uint32		hashkey;</span><br><span class="line">	Bucket		bucket;</span><br><span class="line">	OffsetNumber itup_off;</span><br><span class="line"></span><br><span class="line">	hashkey = _hash_get_indextuple_hashkey(itup);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* compute item size too */</span></span><br><span class="line">	itemsz = IndexTupleSize(itup);</span><br><span class="line">	itemsz = MAXALIGN(itemsz);</span><br><span class="line"></span><br><span class="line">restart_insert:</span><br><span class="line"></span><br><span class="line">	metabuf = _hash_getbuf(rel, HASH_METAPAGE, HASH_NOLOCK, LH_META_PAGE);</span><br><span class="line">	metapage = BufferGetPage(metabuf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (itemsz &gt; HashMaxItemSize(metapage))</span><br><span class="line">		ereport(ERROR,</span><br><span class="line">				(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),</span><br><span class="line">				 errmsg(<span class="string">&quot;index row size %zu exceeds hash maximum %zu&quot;</span>,</span><br><span class="line">						itemsz, HashMaxItemSize(metapage)),</span><br><span class="line">				 errhint(<span class="string">&quot;Values larger than a buffer page cannot be indexed.&quot;</span>)));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Lock the primary bucket page for the target bucket. */</span></span><br><span class="line">	buf = _hash_getbucketbuf_from_hashkey(rel, hashkey, HASH_WRITE,</span><br><span class="line">										  &amp;usedmetap);</span><br><span class="line">	Assert(usedmetap != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	CheckForSerializableConflictIn(rel, <span class="literal">NULL</span>, BufferGetBlockNumber(buf));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* remember the primary bucket buffer to release the pin on it at end. */</span></span><br><span class="line">	bucket_buf = buf;</span><br><span class="line"></span><br><span class="line">	page = BufferGetPage(buf);</span><br><span class="line">	pageopaque = HashPageGetOpaque(page);</span><br><span class="line">	bucket = pageopaque-&gt;hasho_bucket;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (H_BUCKET_BEING_SPLIT(pageopaque) &amp;&amp; IsBufferCleanupOK(buf))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* release the lock on bucket buffer, before completing the split. */</span></span><br><span class="line">		LockBuffer(buf, BUFFER_LOCK_UNLOCK);</span><br><span class="line"></span><br><span class="line">		_hash_finish_split(rel, metabuf, buf, bucket,</span><br><span class="line">						   usedmetap-&gt;hashm_maxbucket,</span><br><span class="line">						   usedmetap-&gt;hashm_highmask,</span><br><span class="line">						   usedmetap-&gt;hashm_lowmask);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* release the pin on old and meta buffer.  retry for insert. */</span></span><br><span class="line">		_hash_dropbuf(rel, buf);</span><br><span class="line">		_hash_dropbuf(rel, metabuf);</span><br><span class="line">		<span class="keyword">goto</span> restart_insert;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Do the insertion */</span></span><br><span class="line">	<span class="keyword">while</span> (PageGetFreeSpace(page) &lt; itemsz)</span><br><span class="line">	&#123;</span><br><span class="line">		BlockNumber nextblkno;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (H_HAS_DEAD_TUPLES(pageopaque))</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (IsBufferCleanupOK(buf))</span><br><span class="line">			&#123;</span><br><span class="line">				_hash_vacuum_one_page(rel, heapRel, metabuf, buf);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (PageGetFreeSpace(page) &gt;= itemsz)</span><br><span class="line">					<span class="keyword">break</span>;		<span class="comment">/* OK, now we have enough space */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		nextblkno = pageopaque-&gt;hasho_nextblkno;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (BlockNumberIsValid(nextblkno))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (buf != bucket_buf)</span><br><span class="line">				_hash_relbuf(rel, buf);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				LockBuffer(buf, BUFFER_LOCK_UNLOCK);</span><br><span class="line">			buf = _hash_getbuf(rel, nextblkno, HASH_WRITE, LH_OVERFLOW_PAGE);</span><br><span class="line">			page = BufferGetPage(buf);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* release our write lock without modifying buffer */</span></span><br><span class="line">			LockBuffer(buf, BUFFER_LOCK_UNLOCK);</span><br><span class="line">            </span><br><span class="line">    *******************************************************************</span><br><span class="line">			<span class="comment">/* 溢出页的分配 */</span></span><br><span class="line">			buf = _hash_addovflpage(rel, metabuf, buf, (buf == bucket_buf));</span><br><span class="line">    *******************************************************************</span><br><span class="line">			page = BufferGetPage(buf);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* should fit now, given test above */</span></span><br><span class="line">			Assert(PageGetFreeSpace(page) &gt;= itemsz);</span><br><span class="line">		&#125;</span><br><span class="line">		pageopaque = HashPageGetOpaque(page);</span><br><span class="line">		Assert((pageopaque-&gt;hasho_flag &amp; LH_PAGE_TYPE) == LH_OVERFLOW_PAGE);</span><br><span class="line">		Assert(pageopaque-&gt;hasho_bucket == bucket);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LockBuffer(metabuf, BUFFER_LOCK_EXCLUSIVE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Do the update.  No ereport(ERROR) until changes are logged */</span></span><br><span class="line">	START_CRIT_SECTION();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* found page with enough space, so add the item here */</span></span><br><span class="line">	itup_off = _hash_pgaddtup(rel, buf, itemsz, itup);</span><br><span class="line">	MarkBufferDirty(buf);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* metapage operations */</span></span><br><span class="line">	metap = HashPageGetMeta(metapage);</span><br><span class="line">	metap-&gt;hashm_ntuples += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make sure this stays in sync with _hash_expandtable() */</span></span><br><span class="line">	do_expand = metap-&gt;hashm_ntuples &gt;</span><br><span class="line">		(<span class="type">double</span>) metap-&gt;hashm_ffactor * (metap-&gt;hashm_maxbucket + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	MarkBufferDirty(metabuf);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* XLOG stuff */</span></span><br><span class="line">	<span class="keyword">if</span> (RelationNeedsWAL(rel))</span><br><span class="line">	&#123;</span><br><span class="line">		xl_hash_insert xlrec;</span><br><span class="line">		XLogRecPtr	recptr;</span><br><span class="line"></span><br><span class="line">		xlrec.offnum = itup_off;</span><br><span class="line"></span><br><span class="line">		XLogBeginInsert();</span><br><span class="line">		XLogRegisterData((<span class="type">char</span> *) &amp;xlrec, SizeOfHashInsert);</span><br><span class="line"></span><br><span class="line">		XLogRegisterBuffer(<span class="number">1</span>, metabuf, REGBUF_STANDARD);</span><br><span class="line"></span><br><span class="line">		XLogRegisterBuffer(<span class="number">0</span>, buf, REGBUF_STANDARD);</span><br><span class="line">		XLogRegisterBufData(<span class="number">0</span>, (<span class="type">char</span> *) itup, IndexTupleSize(itup));</span><br><span class="line"></span><br><span class="line">		recptr = XLogInsert(RM_HASH_ID, XLOG_HASH_INSERT);</span><br><span class="line"></span><br><span class="line">		PageSetLSN(BufferGetPage(buf), recptr);</span><br><span class="line">		PageSetLSN(BufferGetPage(metabuf), recptr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	END_CRIT_SECTION();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* drop lock on metapage, but keep pin */</span></span><br><span class="line">	LockBuffer(metabuf, BUFFER_LOCK_UNLOCK);</span><br><span class="line"></span><br><span class="line">	_hash_relbuf(rel, buf);</span><br><span class="line">	<span class="keyword">if</span> (buf != bucket_buf)</span><br><span class="line">		_hash_dropbuf(rel, bucket_buf);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Attempt to split if a split is needed */</span></span><br><span class="line">	<span class="keyword">if</span> (do_expand)</span><br><span class="line">		_hash_expandtable(rel, metabuf);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Finally drop our pin on the metapage */</span></span><br><span class="line">	_hash_dropbuf(rel, metabuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><span class="icon iconify" data-icon="ri:hand-coin-line"></span></span><div id="reward-comment">I'm so cute. Please give me money.</div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Scay Pig</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://scarypig.github.io/myblog/2023/04/12/postgreSQL%E6%BA%90%E7%A0%81/" title="postgreSQL源码">https://scarypig.github.io/myblog/2023/04/12/postgreSQL%E6%BA%90%E7%A0%81/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/myblog/2023/05/09/postgreSQL%E5%AE%9E%E7%8E%B0%E4%BD%8D%E5%9B%BE%E7%B4%A2%E5%BC%95/" rel="prev" title="postgreSQL实现位图索引"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">postgreSQL实现位图索引</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/myblog/2023/02/28/PostgreSQL/" rel="next" title="postgreSQL"><span class="post-nav-text">postgreSQL</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2023 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> Scay Pig</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v6.3.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.9</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></body></html>