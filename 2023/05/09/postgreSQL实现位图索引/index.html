<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="Scay Pig"><meta name="copyright" content="Scay Pig"><meta name="generator" content="Hexo 6.3.0"><meta name="theme" content="hexo-theme-yun"><title>postgreSQL实现位图索引 | 咕噜咕噜~~</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.4.1/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/myblog/yun.svg"><link rel="mask-icon" href="/myblog/yun.svg" color="#0078E7"><link rel="preload" href="/myblog/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/myblog/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"scarypig.github.io","root":"/myblog/","title":"春风十里不如你","version":"1.10.9","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"fireworks":{"colors":null},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/myblog/css/hexo-theme-yun.css"><script src="/myblog/js/hexo-theme-yun.js" type="module"></script><meta name="description" content="索引扩展的结构设计BMPageState​	在位图索引中，页面类型主要分为三种：元页、溢出页和一般页。用结构体BMPageState记录每一页状态和内容。其中不同类型的页对应的Special Space中结构体不同。 BMPageState结构体内容如下。 123456typedef struct BMPageState&amp;#123;    Page bmps_page;            &#x2F;&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="postgreSQL实现位图索引">
<meta property="og:url" content="https://scarypig.github.io/myblog/2023/05/09/postgreSQL%E5%AE%9E%E7%8E%B0%E4%BD%8D%E5%9B%BE%E7%B4%A2%E5%BC%95/index.html">
<meta property="og:site_name" content="咕噜咕噜~~">
<meta property="og:description" content="索引扩展的结构设计BMPageState​	在位图索引中，页面类型主要分为三种：元页、溢出页和一般页。用结构体BMPageState记录每一页状态和内容。其中不同类型的页对应的Special Space中结构体不同。 BMPageState结构体内容如下。 123456typedef struct BMPageState&amp;#123;    Page bmps_page;            &#x2F;&#x2F;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230509141749964.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230509141835369.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230509141906303.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230509141920514.png">
<meta property="article:published_time" content="2023-05-09T06:15:32.000Z">
<meta property="article:modified_time" content="2023-05-09T06:25:54.660Z">
<meta property="article:author" content="Scay Pig">
<meta property="article:tag" content="pgsql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230509141749964.png"><script>(function() {
  if (CONFIG.mode !== 'auto') return
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/myblog/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/myblog/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/myblog/about/" title="Scay Pig"><img width="96" loading="lazy" src="/myblog/yun.png" alt="Scay Pig"></a><div class="site-author-name"><a href="/myblog/about/">Scay Pig</a></div><span class="site-name">咕噜咕噜~~</span><sub class="site-subtitle"></sub><div class="site-description"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/myblog/" title="首页"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/myblog/archives/" title="归档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">47</span></a></div><div class="site-state-item"><a href="/myblog/categories/" title="分类"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">1</span></a></div><div class="site-state-item"><a href="/myblog/tags/" title="标签"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">20</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:settings-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/ScaryPig" title="GitHub" target="_blank" style="color:#6e5494"><span class="icon iconify" data-icon="ri:github-line"></span></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/myblog/links/" title="我的小伙伴们" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%89%A9%E5%B1%95%E7%9A%84%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.</span> <span class="toc-text">索引扩展的结构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BMPageState"><span class="toc-number">1.1.</span> <span class="toc-text">BMPageState</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BMMetaOpaqueData"><span class="toc-number">1.2.</span> <span class="toc-text">BMMetaOpaqueData</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BMPageOpaqueData"><span class="toc-number">1.3.</span> <span class="toc-text">BMPageOpaqueData</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.4.</span> <span class="toc-text">结构设计</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%BB%BA%E7%AB%8B"><span class="toc-number">2.</span> <span class="toc-text">索引建立</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">索引访问方法处理函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bmbuild%E5%87%BD%E6%95%B0-%E4%B8%BB%E8%A6%81"><span class="toc-number">2.2.</span> <span class="toc-text">bmbuild函数(主要)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bmcostestimate%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">bmcostestimate函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bmbeginscan%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">bmbeginscan函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bmrescan%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">bmrescan函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bmgettuple%E5%87%BD%E6%95%B0-%E4%B8%BB%E8%A6%81"><span class="toc-number">2.6.</span> <span class="toc-text">bmgettuple函数(主要)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bmendscan%E5%87%BD%E6%95%B0"><span class="toc-number">2.7.</span> <span class="toc-text">bmendscan函数</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="https://scarypig.github.io/myblog/myblog/2023/05/09/postgreSQL%E5%AE%9E%E7%8E%B0%E4%BD%8D%E5%9B%BE%E7%B4%A2%E5%BC%95/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Scay Pig"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="咕噜咕噜~~"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">postgreSQL实现位图索引</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="创建时间：2023-05-09 14:15:32" itemprop="dateCreated datePublished" datetime="2023-05-09T14:15:32+08:00">2023-05-09</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><span class="icon iconify" data-icon="ri:folder-line"></span></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/myblog/categories/%E5%AD%A6%E4%B9%A0/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">学习</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/myblog/tags/pgsql/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">pgsql</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="索引扩展的结构设计"><a href="#索引扩展的结构设计" class="headerlink" title="索引扩展的结构设计"></a>索引扩展的结构设计</h1><h2 id="BMPageState"><a href="#BMPageState" class="headerlink" title="BMPageState"></a>BMPageState</h2><p>​	在位图索引中，页面类型主要分为三种：元页、溢出页和一般页。用结构体BMPageState记录每一页状态和内容。其中不同类型的页对应的Special Space中结构体不同。</p>
<p>BMPageState结构体内容如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BMPageState</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Page bmps_page;            <span class="comment">// 当前page所在的内存地址，字符串</span></span><br><span class="line">    BlockNumber bmps_blkno;    <span class="comment">// 当前page对应的物理磁盘块号</span></span><br><span class="line">    OffsetNumber bmps_lastoff; <span class="comment">// 当前page中最后插入索引元组的位移</span></span><br><span class="line">&#125; BMPageState;</span><br></pre></td></tr></table></figure>

<h2 id="BMMetaOpaqueData"><a href="#BMMetaOpaqueData" class="headerlink" title="BMMetaOpaqueData"></a>BMMetaOpaqueData</h2><p><img src="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230509141749964.png" alt="image-20230509141749964" loading="lazy"></p>
<p>​	在元页中，free space中存放itup，itup为堆元组中对应tid与value形成的元组。在Special Space中结构体为BMMetaOpaqueData，其中结构如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/ 元页，在该索引的第<span class="number">0</span>页，纪律bimap索引的基本信息</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BMMetaOpaqueData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    BlockNumber bm_nextblkno;   <span class="comment">// 下一个溢出页的页号</span></span><br><span class="line">    BMPageState *bm_next;   <span class="comment">// 链接的下一页地址</span></span><br><span class="line">    BMPageState *meta_next; <span class="comment">// 下一个溢出页的地址</span></span><br><span class="line">    uint32 bm_bucket;   <span class="comment">// 当前页号</span></span><br><span class="line">    BlockNumber bm_maxpage;      <span class="comment">// 当前最大页号</span></span><br><span class="line">    uint32 bm_attrsum;           <span class="comment">// 记录索引列数</span></span><br><span class="line">    BlockNumber bm_overflowblno; <span class="comment">// 第一个溢出页的块号</span></span><br><span class="line">    uint32 nums;                 <span class="comment">// 循环次数</span></span><br><span class="line">    <span class="type">bool</span> firstx;                 <span class="comment">// 第一次循环时直接创建</span></span><br><span class="line">&#125; BMMetaOpaqueData;</span><br><span class="line"><span class="keyword">typedef</span> BMMetaOpaqueData *BMMetaOpaque;</span><br></pre></td></tr></table></figure>

<h2 id="BMPageOpaqueData"><a href="#BMPageOpaqueData" class="headerlink" title="BMPageOpaqueData"></a>BMPageOpaqueData</h2><p><img src="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230509141835369.png" alt="image-20230509141835369" loading="lazy"></p>
<p>​	一般页中在free space中的头部存放属性值，在之后存放0或1，在Special Space中结构体为BMPageOpaqueData，其中结构如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来描述Special Space域的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BMPageOpaqueData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    BlockNumber bm_nextblkno;    <span class="comment">// 后一页的块号</span></span><br><span class="line">    BMPageState *bm_next;        <span class="comment">// 指向下一页的指针</span></span><br><span class="line">    BlockNumber bm_overflowblno; <span class="comment">// 第一个溢出页的块号</span></span><br><span class="line">    uint32 bm_bucket;            <span class="comment">// 该页面的页号</span></span><br><span class="line">&#125; BMPageOpaqueData;</span><br><span class="line"><span class="keyword">typedef</span> BMPageOpaqueData *BMPageOpaque;</span><br></pre></td></tr></table></figure>

<h2 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h2><p><img src="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230509141906303.png" alt="image-20230509141906303" loading="lazy"></p>
<p>​	如图所示，在少量数据下的单列索引，page0为元页，存放对应表的元组信息，page1、page2…为一般页，存放0&#x2F;1信息。其中page0的Special Space指向page1，page1又指向page2，形成一个链表。</p>
<p><img src="https://raw.githubusercontent.com/ScaryPig/photo/main/images/image-20230509141920514.png" alt="image-20230509141920514" loading="lazy"></p>
<p>​	当page内free space不足，则会生成overflow_page溢出页。</p>
<p>​	在物理上，每一页都是相连的，当建立多列索引时，OpaqueData结构体中bm_next指向与之相连的page，bm_nextblno则指向当前列的下一页的页号，在逻辑上两页相邻，物理上两页不一定相邻。例如：有两列attr1与attr2，attr1的元素对应页为page1、page3、pag4，attr2的元素为page2、page5，则page1的bm_next指向page2，page2的bm_next指向page3。而page1的bm_nextblno指向page3，page2的bm_nextblno指向page5。</p>
<h1 id="索引建立"><a href="#索引建立" class="headerlink" title="索引建立"></a>索引建立</h1><h2 id="索引访问方法处理函数"><a href="#索引访问方法处理函数" class="headerlink" title="索引访问方法处理函数"></a>索引访问方法处理函数</h2><p>​	IndexAmRoutine ，也称为访问方法的API 结构，包括指定访问方法的各种固定属性的字段，例如它是否可以支持多列索引。更重要的是，它包含支持访问方法的函数的指针，这些函数完成了访问索引的所有实际工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IndexAmRoutine</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NodeTag     type;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* * 我们可以遍历/搜索 * 这个 AM 的策略（运算符）总数。如果 AM 没有一组固定的策略分配，则为零。*/</span></span><br><span class="line">    uint16      amstrategies;</span><br><span class="line">    <span class="comment">/* 此 AM 使用的支持函数总数 */</span></span><br><span class="line">    uint16      amsupport;</span><br><span class="line">    <span class="comment">/* opclass 选项支持函数号或 0 */</span></span><br><span class="line">    uint16      amoptsprocnum;</span><br><span class="line">    <span class="comment">/* AM 是否支持 ORDER BY 索引列的值？*/</span></span><br><span class="line">    <span class="type">bool</span>        amcanorder;</span><br><span class="line">    <span class="comment">/* AM 是否支持索引列上的运算符的 ORDER BY 结果？*/</span></span><br><span class="line">    <span class="type">bool</span>        amcanorderbyop;</span><br><span class="line">    <span class="comment">/* AM是否支持反向扫描？*/</span></span><br><span class="line">    <span class="type">bool</span>        amcanbackward;</span><br><span class="line">    <span class="comment">/* AM 是否支持 UNIQUE 索引？*/</span></span><br><span class="line">    <span class="type">bool</span>        amcanunique;</span><br><span class="line">    <span class="comment">/* AM 是否支持多列索引？*/</span></span><br><span class="line">    <span class="type">bool</span>        amcanmulticol;</span><br><span class="line">    <span class="comment">/* AM 是否要求扫描对第一个索引列有约束？*/</span></span><br><span class="line">    <span class="type">bool</span>        amoptionalkey;</span><br><span class="line">    <span class="comment">/* AM 处理 ScalarArrayOpExpr quals 吗？*/</span></span><br><span class="line">    <span class="type">bool</span>        amsearcharray;</span><br><span class="line">    <span class="comment">/* AM 处理 IS NULL/IS NOT NULL quals 吗？*/</span></span><br><span class="line">    <span class="type">bool</span>        amsearchnulls;</span><br><span class="line">    <span class="comment">/* 索引存储数据类型可以与列数据类型不同吗？*/</span></span><br><span class="line">    <span class="type">bool</span>        amstorage;</span><br><span class="line">    <span class="comment">/* 这种类型的索引可以聚集在上面吗？*/</span></span><br><span class="line">    <span class="type">bool</span>        amclusterable;</span><br><span class="line">    <span class="comment">/* AM 处理谓词锁吗？*/</span></span><br><span class="line">    <span class="type">bool</span>        ampredlocks;</span><br><span class="line">    <span class="comment">/* AM是否支持并行扫描？*/</span></span><br><span class="line">    <span class="type">bool</span>        amcanparallel;</span><br><span class="line">    <span class="comment">/* AM 是否支持包含在子句 INCLUDE 中的列？*/</span></span><br><span class="line">    <span class="type">bool</span>        amcaninclude;</span><br><span class="line">    <span class="comment">/* AM是否使用maintenance_work_mem？*/</span></span><br><span class="line">    <span class="type">bool</span>        amusemaintenanceworkmem;</span><br><span class="line">    <span class="comment">/* 并行真空标志的 OR */</span></span><br><span class="line">    uint8       amparallelvacuumoptions;</span><br><span class="line">    <span class="comment">/* 存储在索引中的数据类型，如果变量是 InvalidOid */</span></span><br><span class="line">    Oid         amkeytype;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 接口函数 */</span></span><br><span class="line">    ambuild_function ambuild;</span><br><span class="line">    ambuildempty_function ambuildempty;</span><br><span class="line">    aminsert_function aminsert;</span><br><span class="line">    ambulkdelete_function ambulkdelete;</span><br><span class="line">    amvacuumcleanup_function amvacuumcleanup;</span><br><span class="line">    amcanreturn_function amcanreturn;   <span class="comment">/* 可以为 NULL */</span></span><br><span class="line">    amcostestimate_function amcostestimate;</span><br><span class="line">    amoptions_function amoptions;</span><br><span class="line">    amproperty_function amproperty;     <span class="comment">/* 可以为 NULL */</span></span><br><span class="line">    ambuildphasename_function ambuildphasename;   <span class="comment">/* 可以为 NULL */</span></span><br><span class="line">    amvalidate_function amvalidate;</span><br><span class="line">    amadjustmembers_function amadjustmembers; <span class="comment">/* 可以为 NULL */</span></span><br><span class="line">    ambeginscan_function ambeginscan;</span><br><span class="line">    amrescan_function amrescan;</span><br><span class="line">    amgettuple_function amgettuple;     <span class="comment">/* 可以为 NULL */</span></span><br><span class="line">    amgetbitmap_function amgetbitmap;   <span class="comment">/* 可以为 NULL */</span></span><br><span class="line">    amendscan_function amendscan;</span><br><span class="line">    ammarkpos_function ammarkpos;       <span class="comment">/* 可以为 NULL */</span></span><br><span class="line">    amrestrpos_function amrestrpos;     <span class="comment">/* 可以为 NULL */</span></span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 支持并行索引扫描的接口函数 */</span></span><br><span class="line">    amestimateparallelscan_function amestimateparallelscan;    <span class="comment">/* 可以为 NULL */</span></span><br><span class="line">    aminitparallelscan_function aminitparallelscan;    <span class="comment">/* 可以为 NULL */</span></span><br><span class="line">    amparallelrescan_function amparallelrescan;    <span class="comment">/* 可以为 NULL */</span></span><br><span class="line">&#125; IndexAmRoutine;</span><br></pre></td></tr></table></figure>

<p>​	每种索引访问方法在<a target="_blank" rel="noopener" href="https://runebook.dev/zh/docs/postgresql/catalog-pg-am"> pg_am </a>系统目录中以一行来描述。索引访问方法处理函数必须声明为接受 internal 类型的单个参数并返回伪类型 index_am_handler </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION <span class="title function_">bmhandler</span><span class="params">(internal)</span></span><br><span class="line">RETURNS index_am_handler</span><br><span class="line">AS &#x27;/home/postgres/postgre/postgresql-15.2/contrib/bitmap/bitmap.so&#x27;</span><br><span class="line">LANGUAGE C STRICT PARALLEL RESTRICTED;</span><br></pre></td></tr></table></figure>

<p>下列代码为位图索引的索引访问方法的处理函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Datum <span class="title function_">bmhandler</span><span class="params">(PG_FUNCTION_ARGS)</span></span><br><span class="line">&#123;</span><br><span class="line">    IndexAmRoutine *amroutine = makeNode(IndexAmRoutine);</span><br><span class="line"></span><br><span class="line">    amroutine-&gt;amstrategies = <span class="number">1</span>;</span><br><span class="line">    amroutine-&gt;amsupport = <span class="number">2</span>;</span><br><span class="line">    amroutine-&gt;amoptsprocnum = <span class="number">2</span>;</span><br><span class="line">    amroutine-&gt;amcanorder = <span class="literal">false</span>;</span><br><span class="line">    amroutine-&gt;amcanorderbyop = <span class="literal">false</span>;</span><br><span class="line">    amroutine-&gt;amcanbackward = <span class="literal">false</span>;</span><br><span class="line">    amroutine-&gt;amcanunique = <span class="literal">false</span>;</span><br><span class="line">    amroutine-&gt;amcanmulticol = <span class="literal">true</span>;</span><br><span class="line">    amroutine-&gt;amoptionalkey = <span class="literal">true</span>;</span><br><span class="line">    amroutine-&gt;amsearcharray = <span class="literal">false</span>;</span><br><span class="line">    amroutine-&gt;amsearchnulls = <span class="literal">false</span>;</span><br><span class="line">    amroutine-&gt;amstorage = <span class="literal">false</span>;</span><br><span class="line">    amroutine-&gt;amclusterable = <span class="literal">false</span>;</span><br><span class="line">    amroutine-&gt;ampredlocks = <span class="literal">false</span>;</span><br><span class="line">    amroutine-&gt;amcanparallel = <span class="literal">false</span>;</span><br><span class="line">    amroutine-&gt;amcaninclude = <span class="literal">false</span>;</span><br><span class="line">    amroutine-&gt;amusemaintenanceworkmem = <span class="literal">false</span>;</span><br><span class="line">    amroutine-&gt;amparallelvacuumoptions =</span><br><span class="line">        VACUUM_OPTION_PARALLEL_BULKDEL | VACUUM_OPTION_PARALLEL_CLEANUP;</span><br><span class="line">    amroutine-&gt;amkeytype = InvalidOid;</span><br><span class="line">    amroutine-&gt;ambuild = bmbuild;</span><br><span class="line">    amroutine-&gt;ambuildempty = bmbuildempty;</span><br><span class="line">    amroutine-&gt;aminsert = bminsert;</span><br><span class="line">    amroutine-&gt;ambulkdelete = bmbulkdelete;</span><br><span class="line">    amroutine-&gt;amvacuumcleanup = bmvacuumcleanup;</span><br><span class="line">    amroutine-&gt;amcanreturn = bmcanretutn;</span><br><span class="line">    amroutine-&gt;amcostestimate = bmcostestimate;</span><br><span class="line">    amroutine-&gt;amoptions = bmoptions;</span><br><span class="line">    amroutine-&gt;amproperty = <span class="literal">NULL</span>;</span><br><span class="line">    amroutine-&gt;ambuildphasename = <span class="literal">NULL</span>;</span><br><span class="line">    amroutine-&gt;amvalidate = bmvalidate;</span><br><span class="line">    amroutine-&gt;amadjustmembers = <span class="literal">NULL</span>;</span><br><span class="line">    amroutine-&gt;ambeginscan = bmbeginscan;</span><br><span class="line">    amroutine-&gt;amrescan = bmrescan;</span><br><span class="line">    amroutine-&gt;amgettuple = bmgettuple;</span><br><span class="line">    amroutine-&gt;amgetbitmap = <span class="literal">NULL</span>;</span><br><span class="line">    amroutine-&gt;amendscan = bmendscan;</span><br><span class="line">    amroutine-&gt;ammarkpos = <span class="literal">NULL</span>;</span><br><span class="line">    amroutine-&gt;amrestrpos = <span class="literal">NULL</span>;</span><br><span class="line">    amroutine-&gt;amestimateparallelscan = <span class="literal">NULL</span>;</span><br><span class="line">    amroutine-&gt;aminitparallelscan = <span class="literal">NULL</span>;</span><br><span class="line">    amroutine-&gt;amparallelrescan = <span class="literal">NULL</span>;</span><br><span class="line">    PG_RETURN_POINTER(amroutine);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bmbuild函数-主要"><a href="#bmbuild函数-主要" class="headerlink" title="bmbuild函数(主要)"></a>bmbuild函数(主要)</h2><p>​	bmbuild函数将建立一个新的位图索引，在该函数中首先创建一个元页，再调用table_index_build_scan方法，传入_bm_build_callback函数与元页对堆表进行扫描。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 开始扫描</span></span><br><span class="line">    reltuples = table_index_build_scan(heap, index, indexInfo, <span class="literal">true</span>, <span class="literal">true</span>,</span><br><span class="line">                                       _bm_build_callback, (<span class="type">void</span> *)meta,</span><br><span class="line">                                       <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>​	在callback内对堆表的每一个元组进行处理并插入到位图页，其中tid表示数据记录的物理行当信息，values为创建索引列的列值，state是在bmbuild内创建的结构体。callback最终将形成一个完整的位图索引</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_bm_build_callback(Relation index,</span><br><span class="line">                   ItemPointer tid,</span><br><span class="line">                   Datum *values,</span><br><span class="line">                   <span class="type">bool</span> *isnull,</span><br><span class="line">                   <span class="type">bool</span> tupleIsAlive,</span><br><span class="line">                   <span class="type">void</span> *state)</span><br></pre></td></tr></table></figure>

<h2 id="bmcostestimate函数"><a href="#bmcostestimate函数" class="headerlink" title="bmcostestimate函数"></a>bmcostestimate函数</h2><p>bmcostestimate函数用来估计索引扫描的成本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">oid <span class="title function_">bmcostestimate</span><span class="params">(PlannerInfo *root, IndexPath *path,</span></span><br><span class="line"><span class="params">                    <span class="type">double</span> loop_count, Cost *indexStartupCost,</span></span><br><span class="line"><span class="params">                    Cost *indexTotalCost, Selectivity *indexSelectivity,</span></span><br><span class="line"><span class="params">                    <span class="type">double</span> *indexCorrelation, <span class="type">double</span> *indexPages)</span></span><br><span class="line">&#123;</span><br><span class="line">    GenericCosts costs;</span><br><span class="line"></span><br><span class="line">    MemSet(&amp;costs, <span class="number">0</span>, <span class="keyword">sizeof</span>(costs));</span><br><span class="line">    genericcostestimate(root, path, loop_count, &amp;costs);</span><br><span class="line">    *indexStartupCost = costs.indexStartupCost;</span><br><span class="line">    *indexTotalCost = costs.indexTotalCost;</span><br><span class="line">    *indexSelectivity = costs.indexSelectivity;</span><br><span class="line">    *indexCorrelation = costs.indexCorrelation;</span><br><span class="line">    *indexPages = costs.numIndexPages;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bmbeginscan函数"><a href="#bmbeginscan函数" class="headerlink" title="bmbeginscan函数"></a>bmbeginscan函数</h2><p>​	bmbeginscan函数用来准备索引扫描。其中 nkeys 和 norderbys 参数指示quals和将在扫描中使用排序操作符的数量; 这些对于空间分配可能有用。索引访问方法通过调用 RelationGetIndexScan() 创建保存扫描信息的结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">IndexScanDesc <span class="title function_">bmbeginscan</span><span class="params">(Relation rel, <span class="type">int</span> nkeys, <span class="type">int</span> norderbys)</span></span><br><span class="line">&#123;</span><br><span class="line">    IndexScanDesc scan;</span><br><span class="line">    BMScanOpaque so;</span><br><span class="line">    <span class="comment">/* get the scan */</span></span><br><span class="line">    scan = RelationGetIndexScan(rel, nkeys, norderbys);</span><br><span class="line"></span><br><span class="line">    so = (BMScanOpaque)palloc(<span class="keyword">sizeof</span>(BMScanOpaque) + <span class="keyword">sizeof</span>(ScanKeyData) * <span class="number">10</span>);</span><br><span class="line">    so-&gt;bm_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (scan-&gt;numberOfKeys &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            so-&gt;scankey[i] = (ScanKey)palloc(<span class="keyword">sizeof</span>(ScanKeyData));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        so-&gt;scankey[<span class="number">0</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    scan-&gt;opaque = so;</span><br><span class="line">    <span class="keyword">return</span> scan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在IndexScanDesc中预留了存放自定义结构体的位置，定义BMScanOpaqueData结构体用来保存在bmrescan中的扫描信息，并将其存放在IndexScanDesc中，在之后进行使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BMScanOpaqueData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ScanKey scankey[MAXINDEXNUM]; <span class="comment">// 索引约束条件</span></span><br><span class="line">    <span class="type">int</span> bm_num;                   <span class="comment">// 返回元组的数量</span></span><br><span class="line">    <span class="type">int</span> nscankey;                 <span class="comment">// 索引约束条件的数量</span></span><br><span class="line">&#125; BMScanOpaqueData;</span><br><span class="line"><span class="keyword">typedef</span> BMScanOpaqueData *BMScanOpaque;</span><br></pre></td></tr></table></figure>

<h2 id="bmrescan函数"><a href="#bmrescan函数" class="headerlink" title="bmrescan函数"></a>bmrescan函数</h2><p>​	将在beginscan中存放的对象取出，将扫描得到的scankey、nscankeys存放到BMScanOpaqueData结构体中。其中scankey保存了扫描的每列信息，nscankeys说明了scankey的数量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bmrescan</span><span class="params">(IndexScanDesc scan, ScanKey scankey, <span class="type">int</span> nscankeys,</span></span><br><span class="line"><span class="params">              ScanKey orderbys, <span class="type">int</span> norderbys)</span></span><br><span class="line">&#123;</span><br><span class="line">    BMScanOpaque so = (BMScanOpaque)scan-&gt;opaque;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nscankeys; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        so-&gt;scankey[i] = &amp;scankey[i];</span><br><span class="line">    &#125;</span><br><span class="line">    so-&gt;nscankey = nscankeys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bmgettuple函数-主要"><a href="#bmgettuple函数-主要" class="headerlink" title="bmgettuple函数(主要)"></a>bmgettuple函数(主要)</h2><p>​	获取给定扫描中的下一个元组，沿给定方向dir移动（在索引中向前或向后）。如果获得了元组，将获取到的元组 TID 存储在 scan 结构中，返回 true，如果没有匹配的元组剩余，则返回 false并结束扫描。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">bmgettuple</span><span class="params">(IndexScanDesc scan, ScanDirection dir)</span></span><br></pre></td></tr></table></figure>

<h2 id="bmendscan函数"><a href="#bmendscan函数" class="headerlink" title="bmendscan函数"></a>bmendscan函数</h2><p>​	结束扫描并释放资源。该 scan 结构本身不应该被释放，但访问方法内部采取的任何锁或者销必须被释放，以及根据所分配任何其他存储 ambeginscan 和其他扫描相关的功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bmendscan</span><span class="params">(IndexScanDesc scan)</span></span><br><span class="line">&#123;</span><br><span class="line">    BMScanOpaque so = (BMScanOpaque)scan-&gt;opaque;</span><br><span class="line">    so-&gt;bm_num = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    pfree(so);</span><br><span class="line">    scan-&gt;opaque = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><span class="icon iconify" data-icon="ri:hand-coin-line"></span></span><div id="reward-comment">I'm so cute. Please give me money.</div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Scay Pig</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://scarypig.github.io/myblog/2023/05/09/postgreSQL%E5%AE%9E%E7%8E%B0%E4%BD%8D%E5%9B%BE%E7%B4%A2%E5%BC%95/" title="postgreSQL实现位图索引">https://scarypig.github.io/myblog/2023/05/09/postgreSQL%E5%AE%9E%E7%8E%B0%E4%BD%8D%E5%9B%BE%E7%B4%A2%E5%BC%95/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"></div><div class="post-nav-item"><a class="post-nav-next" href="/myblog/2023/04/12/postgreSQL%E6%BA%90%E7%A0%81/" rel="next" title="postgreSQL源码"><span class="post-nav-text">postgreSQL源码</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2023 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> Scay Pig</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v6.3.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.9</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></body></html>